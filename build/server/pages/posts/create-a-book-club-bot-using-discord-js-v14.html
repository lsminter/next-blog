<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/80754630ffb39469.css" as="style"/><link rel="stylesheet" href="/_next/static/css/80754630ffb39469.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-45f9f9587e6c08e1.js" defer=""></script><script src="/_next/static/chunks/framework-894baf07b784aec6.js" defer=""></script><script src="/_next/static/chunks/main-63854ee67f4963c5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-97df2a3bc2db058c.js" defer=""></script><script src="/_next/static/chunks/963-cdd01fa158147eb6.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-be7f2353613d4a3f.js" defer=""></script><script src="/_next/static/x523rJhSpv55S3vAbYE-S/_buildManifest.js" defer=""></script><script src="/_next/static/x523rJhSpv55S3vAbYE-S/_ssgManifest.js" defer=""></script><script src="/_next/static/x523rJhSpv55S3vAbYE-S/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div class="h-max px-4 sm:px-12 bg-background"><header class="flex justify-between"><div class="flex"><a class="hover:text-blue-600 pt-2" href="/">Lucas Minter</a></div><div class="pt-2"><a class="hover:text-blue-600 px-2" href="/framer-motion">Framer Motion</a><a class="hover:text-blue-600 px-2" href="/posts">Posts</a><a class="hover:text-blue-600 pl-2" href="/">Home</a></div></header><div class="prose mx-auto max-w-4x1"><h1 class="text-center text-3xl">Create a Book Club Bot using Discord.js v14</h1><h4 class="my-4 text-center">by <!-- -->Lucas Minter</h4><p class="my-4 text-center"><a href="/posts">‚Üê go back to all posts</a></p><article><h2 id="introduction">Introduction:</h2>
<p>This tutorial is based off of my course released on <a href="https://egghead.io/courses/build-a-book-club-bot-with-discord-js-501f5be9">egghead.io</a>.</p>
<p>In this tutorial, I will guide you through creating your first Discord bot. We will begin by setting up our bot in the Discord developer portal, followed by setting up the bot locally. I will teach you how to develop a basic chatbot, and then we will dive into creating slash commands with more detail. Finally, we will deploy the bot to ensure it runs continuously.</p>
<p>I have found the following resources to be helpful while developing:</p>
<ul>
<li><a href="https://discordjs.guide/">Discord.js&#39; guide</a> on their website is an excellent resource for learning more about each topic covered in this tutorial.</li>
<li>If you have any questions you can&#39;t figure out, I highly encourage you to check out the <a href="https://discord.com/invite/djs">Discord.js discord channel</a>. However, please try to solve the problem yourself first. Accurately describing the issue and the attempted solutions is a great way to get a quick answer.</li>
<li>The <a href="https://discordstatus.com/">Discord status page</a> is a useful tool to check for any Discord outages. If your bot isn&#39;t working and you can&#39;t find the issue, verifying that everything is running on Discord&#39;s end is a great debugging step.</li>
<li></li>
</ul>
<h2 id="create-and-configure-a-bot-using-the-discord-developer-portal">Create and Configure a Bot using the Discord Developer Portal</h2>
<p>To get started, go to <strong><a href="https://discord.com/developers/applications">https://discord.com/developers/applications</a></strong>. If you do not have an account, you will need to sign up for one. Once you&#39;re in, click &quot;New Application&quot; and name your bot.</p>
<p>In the navigation column on the left, click &quot;Bot,&quot; then click &quot;Add Bot.&quot; This will convert your application into a bot.</p>
<p>Next, click on &quot;OAuth2,&quot; then &quot;URL Generator,&quot; and select &quot;bot&quot; to set the necessary permissions. The specific permissions required will depend on what you want your bot to do. Since we&#39;re creating a book club event bot, we need to grant it the following permissions: manage roles, manage channels, read messages/view channels, moderate members, send messages, manage messages, add reactions, and use slash commands. Copy the generated URL and add it to your Discord channel.</p>
<h2 id="send-your-first-discordjs-bot-event">Send your first Discord.js Bot Event</h2>
<p>To begin, create a directory and navigate to it using the command line. Then, run <strong><code>yarn init -y</code></strong> to generate the initial files. We will also need to install the following dependencies: discord.js, dotenv, and nodemon.</p>
<p>After that, create a <strong><code>.env</code></strong> file to save some variables. In the Discord developer portal, we will need two variables: <strong><code>application id</code></strong>, which will be saved as <strong><code>CLIENT_ID</code></strong>, and a token that can be found by clicking &quot;Reset Token&quot; in the &quot;Bot&quot; section. Save the token in your <strong><code>.env</code></strong> file as <strong><code>TOKEN</code></strong>.</p>
<p>Next, create a <strong><code>main.js</code></strong> file in the root of your directory and import the necessary packages:</p>
<pre><code class="language-jsx">const { Client, Intents } = require(&#39;discord.js&#39;);
require(&#39;dotenv&#39;).config();
</code></pre>
<p>We will then create a new client instance:</p>
<pre><code class="language-jsx">const client = new Client({ intents: [Intents.FLAGS.GUILDS] });
</code></pre>
<p>Once we have created the client, it is common practice to log in to make sure the bot is working as intended:</p>
<pre><code class="language-jsx">client.once(&#39;ready&#39;, () =&gt; {
  console.log(`Ready! Logged in as ${client.user.tag}`);
});
</code></pre>
<p>We can then log in to Discord with our client&#39;s token:</p>
<pre><code class="language-jsx">client.login(process.env.TOKEN);
</code></pre>
<p>Lastly, in <strong><code>package.json</code></strong>, create a development script using nodemon:</p>
<pre><code class="language-json">&quot;scripts&quot;: {
  &quot;dev&quot;: &quot;nodemon main.js&quot;
},
</code></pre>
<p>Run <strong><code>yarn dev</code></strong> to start your bot!</p>
<h2 id="create-your-first-discordjs-bot-message-command">Create your first Discord.js Bot Message Command</h2>
<p>To create your first message command, you need to add the necessary permissions via the <strong><code>GatewayIntentBits</code></strong>. Here is an example of how to set up the client with the required intents:</p>
<pre><code class="language-jsx">const client = new Client({ intents: [ GatewayIntentBits.Guilds, GatewayIntentBits.GuildMessages, GatewayIntentBits.MessageContent ]});
</code></pre>
<p>Using <strong><code>client.on</code></strong>, the bot will check the messages sent in the server to see if they match up with the desired command name, and then reply to that command with some text. Here is an example:</p>
<pre><code class="language-jsx">client.on(&#39;messageCreate&#39;, (message) =&gt; {
  if(message.content === &#39;hello&#39;){
    message.reply(&#39;world&#39;);
  }
});
</code></pre>
<p>If you want to create a simple chatbot, you can keep checking the messages in your server with if/else statements and reply accordingly. However, if you want to create a more intricate bot, you&#39;ll want to use slash commands.</p>
<h2 id="what-are-slash-commands">What are Slash Commands</h2>
<p>Using if/else blocks to create a bot can become cluttered and hard to read as it becomes more complex. However, Slash Commands offer a solution by allowing you to separate commands into individual files and providing helpful configurations.</p>
<p>According to the <strong><a href="https://discordjs.guide/creating-your-bot/slash-commands.html">Discord.js tutorial</a></strong>, here are some advantages of using Slash Commands:</p>
<ul>
<li>Integration with the Discord client interface.</li>
<li>Automatic command detection and parsing of associated options/arguments.</li>
<li>Typed argument inputs for command options, such as &quot;String&quot;, &quot;User&quot;, or &quot;Role&quot;.</li>
<li>Validated or dynamic choices for command options.</li>
<li>In-channel private responses (ephemeral messages).</li>
<li>Pop-up form-style inputs for capturing additional information.</li>
</ul>
<p>Therefore, if you plan on creating a more complex bot, it is recommended to use Slash Commands to keep your code organized and manageable.</p>
<h2 id="setup-files-for-your-first-discordjs-slash-command">Setup Files for your first Discord.js Slash Command</h2>
<p>Thanks to the Discord.js guide, we can use some of their files to set up our project completely for slash commands. While you can have these functions set up in your <strong><code>main.js</code></strong> file, it&#39;s much more readable to extract them into their own folder and files.</p>
<p>Here are five files that I grabbed from the <strong><a href="https://discordjs.guide/creating-your-bot/">Discord.js guide</a></strong> to run slash commands. I won&#39;t go into detail here, so you can either go through their documentation or watch my course on <strong><a href="https://egghead.io/courses/build-a-book-club-bot-with-discord-js-501f5be9">egghead.io</a></strong>.</p>
<p>You can manually add the files listed, or you can <strong><a href="https://github.com/lsminter/discord-bot-template">clone the template</a></strong> I created, fill out the <strong><code>.env</code></strong> file, and be ready for the next section.</p>
<h3 id="mainjs">Main.js</h3>
<pre><code class="language-jsx">const fs = require(&#39;node:fs&#39;)
const path = require(&#39;node:path&#39;)

const { Client, GatewayIntentBits, Collection } = require(&#39;discord.js&#39;);
require(&#39;dotenv&#39;).config()

const client = new Client({ intents: [ GatewayIntentBits.Guilds ]});

client.commands = new Collection();

const commandsPath = path.join(__dirname, &#39;commands&#39;);
const commandFiles = fs.readdirSync(commandsPath).filter(file =&gt; file.endsWith(&#39;.js&#39;));

for (const file of commandFiles) {
    const filePath = path.join(commandsPath, file);
    const command = require(filePath);
    if (&#39;data&#39; in command &amp;&amp; &#39;execute&#39; in command) {
        client.commands.set(command.data.name, command);
    } else {
        console.log(`[WARNING] The command at ${filePath} is missing a required &quot;data&quot; or &quot;execute&quot; property.`);
    }
}

const eventsPath = path.join(__dirname, &#39;events&#39;);
const eventFiles = fs.readdirSync(eventsPath).filter(file =&gt; file.endsWith(&#39;.js&#39;));

for (const file of eventFiles) {
    const filePath = path.join(eventsPath, file);
    const event = require(filePath);
    if (event.once) {
        client.once(event.name, (...args) =&gt; event.execute(...args));
    } else {
        client.on(event.name, (...args) =&gt; event.execute(...args));
  }
}

client.login(process.env.TOKEN);
</code></pre>
<h3 id="eventsinteractioncreatejs">events/interactionCreate.js</h3>
<pre><code class="language-jsx">const { Events } = require(&#39;discord.js&#39;);

module.exports = {
    name: Events.InteractionCreate,
    async execute(interaction) {
        if (!interaction.isChatInputCommand()) return;

        const command = interaction.client.commands.get(interaction.commandName);

        if (!command) {
            console.error(`No command matching ${interaction.commandName} was found.`);
            return;
        }

        try {
            await command.execute(interaction);
        } catch (error) {
            console.error(`Error executing ${interaction.commandName}`);
            console.error(error);
        }
    },
};
</code></pre>
<h3 id="eventsreadyjs">events/ready.js</h3>
<pre><code class="language-jsx">const { Events } = require(&#39;discord.js&#39;);

module.exports = {
    name: Events.ClientReady,
    once: true,
    execute(client) {
        console.log(`Ready! Logged in as ${client.user.tag}`);
    },
};
</code></pre>
<h3 id="deploy-commandsjs">deploy-commands.js</h3>
<pre><code class="language-jsx">const { REST, Routes } = require(&#39;discord.js&#39;);
require(&#39;dotenv&#39;).config()
const fs = require(&#39;node:fs&#39;);

const commands = [];
// Grab all the command files from the commands directory you created earlier
const commandFiles = fs.readdirSync(&#39;./commands&#39;).filter(file =&gt; file.endsWith(&#39;.js&#39;));

// Grab the SlashCommandBuilder#toJSON() output of each command&#39;s data for deployment
for (const file of commandFiles) {
    const command = require(`./commands/${file}`);
    commands.push(command.data.toJSON());
}

// Construct and prepare an instance of the REST module
const rest = new REST({ version: &#39;10&#39; }).setToken(process.env.TOKEN);

// and deploy your commands!
(async () =&gt; {
    try {
        console.log(`Started refreshing ${commands.length} application (/) commands.`);

        // The put method is used to fully refresh all commands in the guild with the current set
        const data = await rest.put(
            Routes.applicationGuildCommands(process.env.CLIENT_ID, process.env.GUILD_ID),
            { body: commands },
        );

        console.log(`Successfully reloaded ${data.length} application (/) commands.`);
    } catch (error) {
        // And of course, make sure you catch and log any errors!
        console.error(error);
    }
})();
</code></pre>
<h3 id="commandspingjs">commands/ping.js</h3>
<pre><code class="language-jsx">
const { SlashCommandBuilder } = require(&#39;discord.js&#39;);

module.exports = {
    data: new SlashCommandBuilder()
        .setName(&#39;ping&#39;)
        .setDescription(&#39;Replies with Pong&#39;),
    async execute(interaction) {
        await interaction.reply(`Pong!`);
    },
};
</code></pre>
<h2 id="create-your-first-discordjs-slash-command">Create your first Discord.js Slash Command</h2>
<p>If you have already cloned the repository, you should have the <strong><code>ping</code></strong> command set up. You can find the code for the file in the section above.</p>
<p>To create a slash command, you need two things: the <strong><code>data</code></strong> property and the <strong><code>execute</code></strong> method. The <strong><code>data</code></strong> property is the definition you give to your command and requires at least two fields, <strong><code>setName</code></strong> and <strong><code>setDescription</code></strong>. The <strong><code>execute</code></strong> method will contain the functionality that your event handler will run.</p>
<p>Discord.js Slash Commands are promise-based, so we will be using <strong><code>async/await</code></strong> in our <strong><code>execute</code></strong> method. If you ever encounter an error and are unsure why, double-checking that you are using <strong><code>async/await</code></strong> correctly is a good place to start.</p>
<p>After creating the command, I will use the single-guild registration for my bot to register the command to my server using <strong><code>node deploy-commands.js</code></strong>. If your bot scales and is in multiple servers, you can register your commands across all servers, but that won&#39;t be necessary for this course. You only need to register your command once.</p>
<h2 id="receive-and-respond-to-input-from-users-with-discordjs-slash-commands">Receive and Respond to Input From Users with Discord.js Slash Commands</h2>
<p>Let&#39;s start by creating the book club command using slash commands. One of the main advantages of using slash commands is that we can prompt users for input using input fields. In this case, we&#39;ll prompt users to enter a book title using <strong><code>addStringOption</code></strong>, the number of people interested using <strong><code>addIntegerOption</code></strong>, and the deadline for submissions using another <strong><code>addIntegerOption</code></strong>. We can make these fields required by using <strong><code>setRequired</code></strong>.</p>
<p>In the <strong><code>execute</code></strong> method, we can retrieve the data entered by the user using <strong><code>getString</code></strong> and <strong><code>getInteger</code></strong> and store them in separate variables. We can also store the username of the user who executed the command in an <strong><code>author</code></strong> variable, which we can later use in our reply message using the <strong><code>reply</code></strong> method.</p>
<h3 id="bookclubjs">bookClub.js</h3>
<pre><code class="language-jsx">const { SlashCommandBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, PermissionsBitField, ChannelType } = require(&#39;discord.js&#39;);

module.exports = {
  data: new SlashCommandBuilder()
    .setName(&#39;bookclub&#39;)
    .setDescription(&#39;Creates a new book club!&#39;)
    .addStringOption(op =&gt;
      op.setName(&#39;book&#39;)
        .setDescription(&#39;The book the book club is on&#39;)
        .setRequired(true)
    )
    .addIntegerOption(op =&gt;
      op.setName(&#39;people&#39;)
        .setDescription(&#39;How many people you want for the club&#39;)
        .setRequired(true)
    )
    .addIntegerOption( op =&gt;
      op.setName(&#39;hours&#39;)
        .setDescription(&#39;When, in hours, you want submissions closed&#39;)
        .setRequired(true)
    )
    ,

  execute(interaction) {
        const book = interaction.options.getString(&#39;book&#39;)
    const numOfPeople = interaction.options.getInteger(&#39;people&#39;)
    const hours = interaction.options.getInteger(&#39;hours&#39;)

        const author = interaction.member.user.username

        interaction.reply(`${author} is looking for ${numOfPeople} people to run a book club on the book ${book}. Submissions end in ${hours} hours.`)
    }
}
</code></pre>
<h2 id="convert-a-discord-slash-command-bot-response-to-an-embedded-message">Convert a Discord Slash Command Bot Response to an Embedded Message</h2>
<p>To streamline bot responses, embedded messages are an effective tool. Firstly, I will generate an appropriate title for the book club by utilizing the user-provided book input. To distinguish between similar book clubs, appending the date to the title is a useful strategy.</p>
<pre><code class="language-jsx">const bookClub = book + &#39; Book Club &#39; + new Date().toDateString()
</code></pre>
<p>Next, I will create an object, which will contain the essential components for an embed message - the <strong><code>title</code></strong> and <strong><code>description</code></strong> of the book club.</p>
<pre><code class="language-jsx">const embedMessage = {
    title: bookClub,
    description: `${author} is going to run a book club on the book ${book}.`,
}
</code></pre>
<p>Following this, a <strong><code>field</code></strong> can be added to display the required number of participants and the expiration of submissions. Although the <strong><code>inline</code></strong> format can be used for numerous fields, I will stick to regular fields, as there are only a few.</p>
<pre><code class="language-jsx">const embedMessage = {
    title: bookClub,
    description: `${author} is going to run a book club on the book ${book}.`,
    fields: [
        {
            name: &#39;Amount of people wanted&#39;,
            value: `${numOfPeople}`
        },
        {
            name: `Submissions close in ${hours} hours`,
            value: `Time runs out in: ${hours} hours`
        }
    ]
}
</code></pre>
<p>Finally, I will respond to the interaction and include the embed message.</p>
<pre><code class="language-jsx">interaction.reply({ embeds: [embedMessage] })
</code></pre>
<h2 id="display-relative-time-in-a-discordjs-embedded-message">Display relative time in a Discord.js Embedded Message</h2>
<p>To make it easier for our users, Discord provides us with a useful function based on the UNIX timestamp. With this, we can display the time relative to the user&#39;s location in Discord. I&#39;ll convert the number of hours given by the user into a UNIX timestamp and then use <strong><code>&lt;t:${hours}:R&gt;</code></strong> to show the relative time to the user.</p>
<pre><code class="language-jsx">const hours = interaction.options.getInteger(&#39;hours&#39;)
const waitTimeInSeconds = (hours * 60) * 60
const timeExpiresAt = Math.floor(new Date().getTime() / 1000) + waitTimeInSeconds

...

{
    name: `Submissions close at &lt;t:${timeExpiresAt}:f&gt;`,
    value: `Time runs out in: &lt;t:${timeExpiresAt}:R&gt;`
}
</code></pre>
<p>There are other ways to display time to our users, and you can find them in the Discord timestamps table on GitHub, as well as more information on the UNIX timestamp.</p>
<p>Resources:</p>
<p><strong><a href="https://gist.github.com/LeviSnoot/d9147767abeef2f770e9ddcd91eb85aa">Discord timestamps table on GitHub</a></strong></p>
<p><strong><a href="https://www.unixtimestamp.com/">UNIX timestamp converter and definition</a></strong></p>
<h2 id="create-custom-discordjs-buttons-with-actionrowbuilder-and-buttonbuilder">Create Custom Discord.js Buttons with ActionRowBuilder and ButtonBuilder</h2>
<p>To allow users to interact with the embedded message and join the book club, a button needs to be created. The following code imports necessary components and sets up a button with three fields:</p>
<pre><code class="language-jsx">const { 
    SlashCommandBuilder, 
    ActionRowBuilder, 
    ButtonBuilder, 
    ButtonStyle, 
    PermissionsBitField,
    ChannelType
} = require(&#39;discord.js&#39;);

const row = new ActionRowBuilder()
    .addComponents(
        new ButtonBuilder()
            .setCustomId(&#39;primary&#39;)
            .setStyle(ButtonStyle.Primary)
            .setEmoji(&#39;üëç&#39;)
    );
</code></pre>
<p>To display the button, it needs to be added as a component to the embedded message object:</p>
<pre><code class="language-jsx">interaction.reply({ embeds: [embedMessage], components: [row]})
</code></pre>
<p>Resources:</p>
<p><a href="https://discordjs.guide/interactions/buttons.html#building-and-sending-buttons">Discord.js Button Guide</a></p>
<p><a href="https://discordjs.guide/interactions/buttons.html#button-styles">Button Styles</a></p>
<h2 id="create-dynamic-channels-and-roles">Create Dynamic Channels and Roles</h2>
<p>In order to ensure that only book club members can view the club channel, we have to create a new channel and a role that will be applied to that channel.</p>
<p>We begin by creating the role for the book club with a name of our choosing and setting the required permissions to view channels and send messages using the following code snippet:</p>
<pre><code class="language-jsx">interaction.guild.roles.create({ 
    name: `${bookClub}`,
    permissions: [
        PermissionsBitField.Flags.ViewChannel,
        PermissionsBitField.Flags.SendMessages
    ]
})
</code></pre>
<p>Then, we get the role ID using <strong><code>interaction.guild.roles.cache.find()</code></strong> method, as shown below:</p>
<pre><code class="language-jsx">const bookClubRoleId = interaction.guild.roles.cache.find(r =&gt; r.name === bookClub).id
</code></pre>
<p>Next, we create the text channel and set permission overwrites to deny access to everyone except members of the book club. This is achieved using the following code snippet:</p>
<pre><code class="language-jsx">interaction.guild.channels.create({
    name: `${bookClub}`,
    type: ChannelType.GuildText,
    permissionOverwrites: [
        {
            id: interaction.guild.id,
            deny: [PermissionsBitField.Flags.ViewChannel]
        },
        {
            id: bookClubRoleId,
            allow:[
                PermissionsBitField.Flags.SendMessages,
                PermissionsBitField.Flags.ViewChannel
            ]
        }
    ]
})
</code></pre>
<p>Finally, we need to add <strong><code>async</code></strong> to the <strong><code>execute</code></strong> function and use <strong><code>await</code></strong> for the interactions, as Discord.js is promise-based. The modified code looks like this:</p>
<pre><code class="language-jsx">async execute(interaction) {

await interaction.reply({ embeds: [embedMessage], components: [row]})

await interaction.guild.roles.create({

const bookClubRoleId = await interaction.guild.roles.cache.find(r =&gt; r.name === bookClub).id

await interaction.guild.channels.create({
</code></pre>
<p>We do this because Discord.js is promise-based, and without adding async/await, the calls might work occasionally, but they will not work properly all of the time.</p>
<h2 id="add-roles-to-users-using-a-discordjs-collector">Add Roles to Users using a Discord.js Collector</h2>
<p>Collectors are essential to gather information from users, and there are various types of collectors you can utilize. Before we get started, we must save our embedded message to a variable so we can attach a collector to it later on.</p>
<pre><code class="language-jsx">const finishedEmbedMessage = await interaction.reply({ embeds: [embedMessage], components: [row]})
</code></pre>
<p>Since we are using a button component on a message, we will use the <strong><code>createMessageComponentCollector</code></strong> collector.</p>
<p>The collector requires three fields: a <strong><code>filter</code></strong> to verify if users do not have the book club role.</p>
<pre><code class="language-jsx">const filter = i =&gt; {
    return interaction.guild.members.cache.get(i.user.id).roles.cache.has(bookClubRoleId) === false
}
</code></pre>
<p><strong><code>max</code></strong> to specify the maximum number of items we want our collector to collect, and <strong><code>time</code></strong> to turn off the collector after a certain amount of time if we do not reach the maximum. We will need to convert the hours into milliseconds for the <strong><code>time</code></strong> variable.</p>
<pre><code class="language-jsx">const waitTimeInMilliseconds = waitTimeInSeconds * 1000

const collector = finishedEmbedMessage.createMessageComponentCollector({ filter, max: numOfPeople, time: waitTimeInMilliseconds})
</code></pre>
<p>Now, let&#39;s enable our collector. Inside this function is where we will add the role to our users. First, let us retrieve the ID of our user and store it in a variable: <strong><code>interaction.guild.members.cache.get(i.user.id)</code></strong>. With that ID, we can then add the book club role using the book club role ID.</p>
<p>Once that is complete, we want to send a message to ensure our users are aware that they were added to the book club. We will use a simple reply to display <strong><code>username has been added to the book club!</code>.</strong></p>
<pre><code class="language-jsx">collector.on(&#39;collect&#39;, i =&gt; {
    const userById = interaction.guild.members.cache.get(i.user.id)
    userById.roles.add(bookClubRoleId)
    i.reply({content: `${i.user.username} has been added to the book club!`})
})
</code></pre>
<p>Lastly, let&#39;s turn off our collector. We will use <strong><code>console.log</code></strong> to output <strong><code>collected</code></strong>.</p>
<pre><code class="language-jsx">collector.on(&#39;end&#39;, c =&gt; {
    console.log(&#39;collected&#39;
})
</code></pre>
<p>Resources:</p>
<p><a href="https://discordjs.guide/popular-topics/collectors.html#interaction-collectors">Discord.js Collectors Guide</a></p>
<h2 id="conditionally-disable-a-custom-discordjs-button">Conditionally Disable a Custom Discord.js Button</h2>
<p>There are two issues that require solving. Presently, when a user with the book club role clicks the button, they receive an error message. Additionally, even if submissions are closed, users can still click the button. To improve the user experience, I will add code to display a more appropriate message when someone clicks the button but already has the book club role. I will also disable the button once submissions are closed.</p>
<p>To handle the first issue, I will add an <strong><code>if</code></strong> statement to the <strong><code>filter</code></strong> function to check the user&#39;s roles. If the user already has the book club role, a hidden message will be sent to them using <strong><code>ephemeral</code></strong> to let them know they have already been added.</p>
<pre><code class="language-jsx">const filter = i =&gt; {
    if (interaction.guild.members.cache.get(i.user.id).roles.cache.has(bookClubRoleId) === true) {
        i.reply({content: `You&#39;ve already been added to the book club.`, ephemeral: true})
    }
    return interaction.guild.members.cache.get(i.user.id).roles.cache.has(bookClubRoleId) === false
}
</code></pre>
<p>To disable the button, I will create a new button using <strong><code>ActionRowBuilder</code></strong> and set the <strong><code>setDisabled(true)</code></strong> property to make it unclickable. Finally, I will use <strong><code>interaction.editReply()</code></strong> to update the original reply and add the new button.</p>
<pre><code class="language-jsx">const disabledButton = new ActionRowBuilder()
    .addComponents(
        new ButtonBuilder()
            .setCustomId(&#39;primary&#39;)
            .setStyle(ButtonStyle.Primary)
            .setLabel(&#39;Submissions Closed&#39;)
            .setDisabled(true)
    );

...

collector.on(&#39;end&#39;, c =&gt; {
    interaction.editReply({embeds: [embedMessage], components: [disabledButton]})
})
</code></pre>
<p>Lastly, for additional information, I will log out the size of our collection.</p>
<pre><code class="language-jsx">collector.on(&#39;end&#39;, c =&gt; {
    interaction.editReply({embeds: [embedMessage], components: [disabledButton]})
    console.log(`collected ${c.size}`)
})
</code></pre>
<h2 id="deploy-a-discordjs-bot-for-production">Deploy a Discord.js Bot for Production</h2>
<p>To deploy the bot in its finished state, I will create a new GitHub repository and push the code to it, making sure to ignore the <strong><code>node_modules</code></strong> directory and the <strong><code>.env</code></strong> file by adding them to the <strong><code>.gitignore</code></strong> file.</p>
<p>For deployment, I will use <strong><a href="http://railway.app/">railway.app</a></strong>. If necessary, I will create an account and select <strong><code>start a new project</code></strong>, then choose my repository from the <strong><code>deploy from GitHub</code></strong> option. After adding the environment variables, I can deploy the bot!</p>
<h2 id="conclusion">Conclusion</h2>
<p>Building a Book Club Bot with Discord.js is a fun and challenging project that can help you hone your programming skills while providing a valuable tool for managing your book club. By following the steps outlined in this tutorial, you should now have a solid understanding of how to create a Discord bot, interact with the Discord API, and utilize various libraries such as Discord.js and Dotenv. From creating custom commands and buttons to handling interactions and deploying your bot, this tutorial has covered all the essential aspects of building a book club bot. So what are you waiting for? Grab your favorite programming language and start building your own book club bot today!</p>
<h3 id="resources-list">Resources List</h3>
<ul>
<li><a href="https://discordjs.guide/">Discord.js&#39; guide</a></li>
<li><a href="https://discord.com/invite/djs">Discord.js discord channel</a></li>
<li><a href="https://discordstatus.com/">Discord status page</a></li>
<li><a href="https://discord.com/developers/applications">Discord Developer Portal</a></li>
<li><a href="https://discordjs.guide/creating-your-bot/slash-commands.html#before-you-continue">Discord.js Slash Commands</a></li>
<li><a href="https://github.com/lsminter/discord-bot-template">Bot Template Repo</a></li>
<li><a href="https://gist.github.com/LeviSnoot/d9147767abeef2f770e9ddcd91eb85aa">Discord timestamps table on GitHub</a></li>
<li><a href="https://www.unixtimestamp.com/">UNIX timestamp converter and definition</a></li>
<li><a href="https://discordjs.guide/interactions/buttons.html#building-and-sending-buttons">Discord.js Button Guide</a></li>
<li><a href="https://discordjs.guide/interactions/buttons.html#button-styles">Button Styles</a></li>
<li><a href="https://discordjs.guide/popular-topics/collectors.html#interaction-collectors">Discord.js Collectors Guide</a></li>
<li><a href="http://railway.app/">railway.app</a></li>
</ul>
</article></div><footer class="flex justify-between mt-4"><div class="text-sm items-center">Lucas Minter ¬©<!-- -->2023</div><div class="flex"><div><a class="hover:text-gray-600" href="https://twitter.com/LucasMinter2"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAiIGhlaWdodD0iMzAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmVyc2lvbj0iMS4xIi8+"/></span><img alt="Twitter Logo" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%"/><noscript><img alt="Twitter Logo" srcSet="_next/static/media/twitterLogo.01f5f683.png?imwidth=32 1x, _next/static/media/twitterLogo.01f5f683.png?imwidth=64 2x" src="_next/static/media/twitterLogo.01f5f683.png?imwidth=64" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%" loading="lazy"/></noscript></span></a></div><div><a class="hover:text-gray-600" href="https://github.com/lsminter"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjUiIGhlaWdodD0iMjUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmVyc2lvbj0iMS4xIi8+"/></span><img alt="Github Logo" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%"/><noscript><img alt="Github Logo" srcSet="_next/static/media/githubLogo.c07b0dc3.png?imwidth=32 1x, _next/static/media/githubLogo.c07b0dc3.png?imwidth=64 2x" src="_next/static/media/githubLogo.c07b0dc3.png?imwidth=64" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%" loading="lazy"/></noscript></span></a></div></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"author":{"_createdAt":"2023-01-20T23:21:59Z","_id":"c87c5c26-aeb7-4a10-812d-98cb53801f40","_rev":"Jbh3e9W2SIs3qJeiZBiBWQ","_type":"author","_updatedAt":"2023-01-20T23:21:59Z","bio":[{"_key":"db9c4c531c02","_type":"block","children":[{"_key":"f311882b8511","_type":"span","marks":[],"text":"Author and creator of this blog."}],"markDefs":[],"style":"normal"}],"image":{"_type":"image","asset":{"_ref":"image-4685b1085a6d182cb91a1d85fd6878a604694ee6-1355x1799-jpg","_type":"reference"}},"name":"Lucas Minter","slug":{"_type":"slug","current":"lucas-minter"}},"body":"## Introduction:\n\nThis tutorial is based off of my course released on [egghead.io](https://egghead.io/courses/build-a-book-club-bot-with-discord-js-501f5be9).\n\nIn this tutorial, I will guide you through creating your first Discord bot. We will begin by setting up our bot in the Discord developer portal, followed by setting up the bot locally. I will teach you how to develop a basic chatbot, and then we will dive into creating slash commands with more detail. Finally, we will deploy the bot to ensure it runs continuously.\n\nI have found the following resources to be helpful while developing:\n\n- [Discord.js' guide](https://discordjs.guide/) on their website is an excellent resource for learning more about each topic covered in this tutorial.\n- If you have any questions you can't figure out, I highly encourage you to check out the [Discord.js discord channel](https://discord.com/invite/djs). However, please try to solve the problem yourself first. Accurately describing the issue and the attempted solutions is a great way to get a quick answer.\n- The [Discord status page](https://discordstatus.com/) is a useful tool to check for any Discord outages. If your bot isn't working and you can't find the issue, verifying that everything is running on Discord's end is a great debugging step.\n- \n\n## Create and Configure a Bot using the Discord Developer Portal\n\nTo get started, go to **[https://discord.com/developers/applications](https://discord.com/developers/applications)**. If you do not have an account, you will need to sign up for one. Once you're in, click \"New Application\" and name your bot.\n\nIn the navigation column on the left, click \"Bot,\" then click \"Add Bot.\" This will convert your application into a bot.\n\nNext, click on \"OAuth2,\" then \"URL Generator,\" and select \"bot\" to set the necessary permissions. The specific permissions required will depend on what you want your bot to do. Since we're creating a book club event bot, we need to grant it the following permissions: manage roles, manage channels, read messages/view channels, moderate members, send messages, manage messages, add reactions, and use slash commands. Copy the generated URL and add it to your Discord channel.\n\n\n## Send your first Discord.js Bot Event\n\nTo begin, create a directory and navigate to it using the command line. Then, run **`yarn init -y`** to generate the initial files. We will also need to install the following dependencies: discord.js, dotenv, and nodemon.\n\nAfter that, create a **`.env`** file to save some variables. In the Discord developer portal, we will need two variables: **`application id`**, which will be saved as **`CLIENT_ID`**, and a token that can be found by clicking \"Reset Token\" in the \"Bot\" section. Save the token in your **`.env`** file as **`TOKEN`**.\n\nNext, create a **`main.js`** file in the root of your directory and import the necessary packages:\n\n```jsx\nconst { Client, Intents } = require('discord.js');\nrequire('dotenv').config();\n```\n\nWe will then create a new client instance:\n\n```jsx\nconst client = new Client({ intents: [Intents.FLAGS.GUILDS] });\n```\n\nOnce we have created the client, it is common practice to log in to make sure the bot is working as intended:\n\n```jsx\nclient.once('ready', () =\u003e {\n  console.log(`Ready! Logged in as ${client.user.tag}`);\n});\n```\n\nWe can then log in to Discord with our client's token:\n\n```jsx\nclient.login(process.env.TOKEN);\n```\n\nLastly, in **`package.json`**, create a development script using nodemon:\n\n```json\n\"scripts\": {\n  \"dev\": \"nodemon main.js\"\n},\n```\n\nRun **`yarn dev`** to start your bot!\n\n\n## Create your first Discord.js Bot Message Command\n\nTo create your first message command, you need to add the necessary permissions via the **`GatewayIntentBits`**. Here is an example of how to set up the client with the required intents:\n\n```jsx\nconst client = new Client({ intents: [ GatewayIntentBits.Guilds, GatewayIntentBits.GuildMessages, GatewayIntentBits.MessageContent ]});\n```\n\nUsing **`client.on`**, the bot will check the messages sent in the server to see if they match up with the desired command name, and then reply to that command with some text. Here is an example:\n\n```jsx\nclient.on('messageCreate', (message) =\u003e {\n  if(message.content === 'hello'){\n    message.reply('world');\n  }\n});\n```\n\nIf you want to create a simple chatbot, you can keep checking the messages in your server with if/else statements and reply accordingly. However, if you want to create a more intricate bot, you'll want to use slash commands.\n\n\n## What are Slash Commands\n\nUsing if/else blocks to create a bot can become cluttered and hard to read as it becomes more complex. However, Slash Commands offer a solution by allowing you to separate commands into individual files and providing helpful configurations.\n\nAccording to the **[Discord.js tutorial](https://discordjs.guide/creating-your-bot/slash-commands.html)**, here are some advantages of using Slash Commands:\n\n- Integration with the Discord client interface.\n- Automatic command detection and parsing of associated options/arguments.\n- Typed argument inputs for command options, such as \"String\", \"User\", or \"Role\".\n- Validated or dynamic choices for command options.\n- In-channel private responses (ephemeral messages).\n- Pop-up form-style inputs for capturing additional information.\n\nTherefore, if you plan on creating a more complex bot, it is recommended to use Slash Commands to keep your code organized and manageable.\n\n\n## Setup Files for your first Discord.js Slash Command\n\nThanks to the Discord.js guide, we can use some of their files to set up our project completely for slash commands. While you can have these functions set up in your **`main.js`** file, it's much more readable to extract them into their own folder and files.\n\nHere are five files that I grabbed from the **[Discord.js guide](https://discordjs.guide/creating-your-bot/)** to run slash commands. I won't go into detail here, so you can either go through their documentation or watch my course on **[egghead.io](https://egghead.io/courses/build-a-book-club-bot-with-discord-js-501f5be9)**.\n\nYou can manually add the files listed, or you can **[clone the template](https://github.com/lsminter/discord-bot-template)** I created, fill out the **`.env`** file, and be ready for the next section.\n\n### Main.js\n\n```jsx\nconst fs = require('node:fs')\nconst path = require('node:path')\n\nconst { Client, GatewayIntentBits, Collection } = require('discord.js');\nrequire('dotenv').config()\n\nconst client = new Client({ intents: [ GatewayIntentBits.Guilds ]});\n\nclient.commands = new Collection();\n\nconst commandsPath = path.join(__dirname, 'commands');\nconst commandFiles = fs.readdirSync(commandsPath).filter(file =\u003e file.endsWith('.js'));\n\nfor (const file of commandFiles) {\n\tconst filePath = path.join(commandsPath, file);\n\tconst command = require(filePath);\n\tif ('data' in command \u0026\u0026 'execute' in command) {\n\t\tclient.commands.set(command.data.name, command);\n\t} else {\n\t\tconsole.log(`[WARNING] The command at ${filePath} is missing a required \"data\" or \"execute\" property.`);\n\t}\n}\n\nconst eventsPath = path.join(__dirname, 'events');\nconst eventFiles = fs.readdirSync(eventsPath).filter(file =\u003e file.endsWith('.js'));\n\nfor (const file of eventFiles) {\n\tconst filePath = path.join(eventsPath, file);\n\tconst event = require(filePath);\n\tif (event.once) {\n\t\tclient.once(event.name, (...args) =\u003e event.execute(...args));\n\t} else {\n\t\tclient.on(event.name, (...args) =\u003e event.execute(...args));\n  }\n}\n\nclient.login(process.env.TOKEN);\n```\n\n### events/interactionCreate.js\n\n```jsx\nconst { Events } = require('discord.js');\n\nmodule.exports = {\n\tname: Events.InteractionCreate,\n\tasync execute(interaction) {\n\t\tif (!interaction.isChatInputCommand()) return;\n\n\t\tconst command = interaction.client.commands.get(interaction.commandName);\n\n\t\tif (!command) {\n\t\t\tconsole.error(`No command matching ${interaction.commandName} was found.`);\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tawait command.execute(interaction);\n\t\t} catch (error) {\n\t\t\tconsole.error(`Error executing ${interaction.commandName}`);\n\t\t\tconsole.error(error);\n\t\t}\n\t},\n};\n```\n\n### events/ready.js\n\n```jsx\nconst { Events } = require('discord.js');\n\nmodule.exports = {\n\tname: Events.ClientReady,\n\tonce: true,\n\texecute(client) {\n\t\tconsole.log(`Ready! Logged in as ${client.user.tag}`);\n\t},\n};\n```\n\n### deploy-commands.js\n\n```jsx\nconst { REST, Routes } = require('discord.js');\nrequire('dotenv').config()\nconst fs = require('node:fs');\n\nconst commands = [];\n// Grab all the command files from the commands directory you created earlier\nconst commandFiles = fs.readdirSync('./commands').filter(file =\u003e file.endsWith('.js'));\n\n// Grab the SlashCommandBuilder#toJSON() output of each command's data for deployment\nfor (const file of commandFiles) {\n\tconst command = require(`./commands/${file}`);\n\tcommands.push(command.data.toJSON());\n}\n\n// Construct and prepare an instance of the REST module\nconst rest = new REST({ version: '10' }).setToken(process.env.TOKEN);\n\n// and deploy your commands!\n(async () =\u003e {\n\ttry {\n\t\tconsole.log(`Started refreshing ${commands.length} application (/) commands.`);\n\n\t\t// The put method is used to fully refresh all commands in the guild with the current set\n\t\tconst data = await rest.put(\n\t\t\tRoutes.applicationGuildCommands(process.env.CLIENT_ID, process.env.GUILD_ID),\n\t\t\t{ body: commands },\n\t\t);\n\n\t\tconsole.log(`Successfully reloaded ${data.length} application (/) commands.`);\n\t} catch (error) {\n\t\t// And of course, make sure you catch and log any errors!\n\t\tconsole.error(error);\n\t}\n})();\n```\n\n### commands/ping.js\n\n```jsx\n\nconst { SlashCommandBuilder } = require('discord.js');\n\nmodule.exports = {\n\tdata: new SlashCommandBuilder()\n\t\t.setName('ping')\n\t\t.setDescription('Replies with Pong'),\n\tasync execute(interaction) {\n\t\tawait interaction.reply(`Pong!`);\n\t},\n};\n```\n\n\n## Create your first Discord.js Slash Command\n\nIf you have already cloned the repository, you should have the **`ping`** command set up. You can find the code for the file in the section above.\n\nTo create a slash command, you need two things: the **`data`** property and the **`execute`** method. The **`data`** property is the definition you give to your command and requires at least two fields, **`setName`** and **`setDescription`**. The **`execute`** method will contain the functionality that your event handler will run.\n\nDiscord.js Slash Commands are promise-based, so we will be using **`async/await`** in our **`execute`** method. If you ever encounter an error and are unsure why, double-checking that you are using **`async/await`** correctly is a good place to start.\n\nAfter creating the command, I will use the single-guild registration for my bot to register the command to my server using **`node deploy-commands.js`**. If your bot scales and is in multiple servers, you can register your commands across all servers, but that won't be necessary for this course. You only need to register your command once.\n\n\n## Receive and Respond to Input From Users with Discord.js Slash Commands\n\nLet's start by creating the book club command using slash commands. One of the main advantages of using slash commands is that we can prompt users for input using input fields. In this case, we'll prompt users to enter a book title using **`addStringOption`**, the number of people interested using **`addIntegerOption`**, and the deadline for submissions using another **`addIntegerOption`**. We can make these fields required by using **`setRequired`**.\n\nIn the **`execute`** method, we can retrieve the data entered by the user using **`getString`** and **`getInteger`** and store them in separate variables. We can also store the username of the user who executed the command in an **`author`** variable, which we can later use in our reply message using the **`reply`** method.\n\n### bookClub.js\n\n```jsx\nconst { SlashCommandBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, PermissionsBitField, ChannelType } = require('discord.js');\n\nmodule.exports = {\n  data: new SlashCommandBuilder()\n    .setName('bookclub')\n    .setDescription('Creates a new book club!')\n    .addStringOption(op =\u003e\n      op.setName('book')\n        .setDescription('The book the book club is on')\n        .setRequired(true)\n    )\n    .addIntegerOption(op =\u003e\n      op.setName('people')\n        .setDescription('How many people you want for the club')\n        .setRequired(true)\n    )\n    .addIntegerOption( op =\u003e\n      op.setName('hours')\n        .setDescription('When, in hours, you want submissions closed')\n        .setRequired(true)\n    )\n    ,\n\n  execute(interaction) {\n\t\tconst book = interaction.options.getString('book')\n    const numOfPeople = interaction.options.getInteger('people')\n    const hours = interaction.options.getInteger('hours')\n\n\t\tconst author = interaction.member.user.username\n\n\t\tinteraction.reply(`${author} is looking for ${numOfPeople} people to run a book club on the book ${book}. Submissions end in ${hours} hours.`)\n\t}\n}\n\n```\n\n\n## Convert a Discord Slash Command Bot Response to an Embedded Message\n\nTo streamline bot responses, embedded messages are an effective tool. Firstly, I will generate an appropriate title for the book club by utilizing the user-provided book input. To distinguish between similar book clubs, appending the date to the title is a useful strategy.\n\n```jsx\nconst bookClub = book + ' Book Club ' + new Date().toDateString()\n```\n\nNext, I will create an object, which will contain the essential components for an embed message - the **`title`** and **`description`** of the book club.\n\n```jsx\nconst embedMessage = {\n\ttitle: bookClub,\n\tdescription: `${author} is going to run a book club on the book ${book}.`,\n}\n```\n\nFollowing this, a **`field`** can be added to display the required number of participants and the expiration of submissions. Although the **`inline`** format can be used for numerous fields, I will stick to regular fields, as there are only a few.\n\n```jsx\nconst embedMessage = {\n\ttitle: bookClub,\n\tdescription: `${author} is going to run a book club on the book ${book}.`,\n\tfields: [\n\t\t{\n\t\t\tname: 'Amount of people wanted',\n\t\t\tvalue: `${numOfPeople}`\n\t\t},\n\t\t{\n\t\t\tname: `Submissions close in ${hours} hours`,\n\t\t\tvalue: `Time runs out in: ${hours} hours`\n\t\t}\n\t]\n}\n```\n\nFinally, I will respond to the interaction and include the embed message.\n\n```jsx\ninteraction.reply({ embeds: [embedMessage] })\n```\n\n\n## Display relative time in a Discord.js Embedded Message\n\nTo make it easier for our users, Discord provides us with a useful function based on the UNIX timestamp. With this, we can display the time relative to the user's location in Discord. I'll convert the number of hours given by the user into a UNIX timestamp and then use **`\u003ct:${hours}:R\u003e`** to show the relative time to the user.\n\n```jsx\nconst hours = interaction.options.getInteger('hours')\nconst waitTimeInSeconds = (hours * 60) * 60\nconst timeExpiresAt = Math.floor(new Date().getTime() / 1000) + waitTimeInSeconds\n\n...\n\n{\n\tname: `Submissions close at \u003ct:${timeExpiresAt}:f\u003e`,\n\tvalue: `Time runs out in: \u003ct:${timeExpiresAt}:R\u003e`\n}\n```\n\nThere are other ways to display time to our users, and you can find them in the Discord timestamps table on GitHub, as well as more information on the UNIX timestamp.\n\nResources:\n\n**[Discord timestamps table on GitHub](https://gist.github.com/LeviSnoot/d9147767abeef2f770e9ddcd91eb85aa)**\n\n**[UNIX timestamp converter and definition](https://www.unixtimestamp.com/)**\n\n\n## Create Custom Discord.js Buttons with ActionRowBuilder and ButtonBuilder\n\nTo allow users to interact with the embedded message and join the book club, a button needs to be created. The following code imports necessary components and sets up a button with three fields:\n\n```jsx\nconst { \n\tSlashCommandBuilder, \n\tActionRowBuilder, \n\tButtonBuilder, \n\tButtonStyle, \n\tPermissionsBitField,\n\tChannelType\n} = require('discord.js');\n\nconst row = new ActionRowBuilder()\n\t.addComponents(\n\t\tnew ButtonBuilder()\n\t\t\t.setCustomId('primary')\n\t\t\t.setStyle(ButtonStyle.Primary)\n\t\t\t.setEmoji('üëç')\n\t);\n```\n\nTo display the button, it needs to be added as a component to the embedded message object:\n\n```jsx\ninteraction.reply({ embeds: [embedMessage], components: [row]})\n```\n\nResources:\n\n[Discord.js Button Guide](https://discordjs.guide/interactions/buttons.html#building-and-sending-buttons)\n\n[Button Styles](https://discordjs.guide/interactions/buttons.html#button-styles)\n\n\n## Create Dynamic Channels and Roles\n\nIn order to ensure that only book club members can view the club channel, we have to create a new channel and a role that will be applied to that channel.\n\nWe begin by creating the role for the book club with a name of our choosing and setting the required permissions to view channels and send messages using the following code snippet:\n\n```jsx\ninteraction.guild.roles.create({ \n\tname: `${bookClub}`,\n\tpermissions: [\n\t\tPermissionsBitField.Flags.ViewChannel,\n\t\tPermissionsBitField.Flags.SendMessages\n\t]\n})\n```\n\nThen, we get the role ID using **`interaction.guild.roles.cache.find()`** method, as shown below:\n\n```jsx\nconst bookClubRoleId = interaction.guild.roles.cache.find(r =\u003e r.name === bookClub).id\n```\n\nNext, we create the text channel and set permission overwrites to deny access to everyone except members of the book club. This is achieved using the following code snippet:\n\n```jsx\ninteraction.guild.channels.create({\n\tname: `${bookClub}`,\n\ttype: ChannelType.GuildText,\n\tpermissionOverwrites: [\n\t\t{\n\t\t\tid: interaction.guild.id,\n\t\t\tdeny: [PermissionsBitField.Flags.ViewChannel]\n\t\t},\n\t\t{\n\t\t\tid: bookClubRoleId,\n\t\t\tallow:[\n\t\t\t\tPermissionsBitField.Flags.SendMessages,\n\t\t\t\tPermissionsBitField.Flags.ViewChannel\n\t\t\t]\n\t\t}\n\t]\n})\n```\n\nFinally, we need to add **`async`** to the **`execute`** function and use **`await`** for the interactions, as Discord.js is promise-based. The modified code looks like this:\n\n```jsx\nasync execute(interaction) {\n\nawait interaction.reply({ embeds: [embedMessage], components: [row]})\n\nawait interaction.guild.roles.create({\n\nconst bookClubRoleId = await interaction.guild.roles.cache.find(r =\u003e r.name === bookClub).id\n\nawait interaction.guild.channels.create({\n```\n\nWe do this because Discord.js is promise-based, and without adding async/await, the calls might work occasionally, but they will not work properly all of the time.\n\n\n## Add Roles to Users using a Discord.js Collector\n\nCollectors are essential to gather information from users, and there are various types of collectors you can utilize. Before we get started, we must save our embedded message to a variable so we can attach a collector to it later on.\n\n```jsx\nconst finishedEmbedMessage = await interaction.reply({ embeds: [embedMessage], components: [row]})\n```\n\nSince we are using a button component on a message, we will use the **`createMessageComponentCollector`** collector.\n\nThe collector requires three fields: a **`filter`** to verify if users do not have the book club role.\n\n```jsx\nconst filter = i =\u003e {\n\treturn interaction.guild.members.cache.get(i.user.id).roles.cache.has(bookClubRoleId) === false\n}\n```\n\n**`max`** to specify the maximum number of items we want our collector to collect, and **`time`** to turn off the collector after a certain amount of time if we do not reach the maximum. We will need to convert the hours into milliseconds for the **`time`** variable.\n\n```jsx\nconst waitTimeInMilliseconds = waitTimeInSeconds * 1000\n\nconst collector = finishedEmbedMessage.createMessageComponentCollector({ filter, max: numOfPeople, time: waitTimeInMilliseconds})\n```\n\nNow, let's enable our collector. Inside this function is where we will add the role to our users. First, let us retrieve the ID of our user and store it in a variable: **`interaction.guild.members.cache.get(i.user.id)`**. With that ID, we can then add the book club role using the book club role ID.\n\nOnce that is complete, we want to send a message to ensure our users are aware that they were added to the book club. We will use a simple reply to display **`username has been added to the book club!`.**\n\n```jsx\ncollector.on('collect', i =\u003e {\n\tconst userById = interaction.guild.members.cache.get(i.user.id)\n\tuserById.roles.add(bookClubRoleId)\n\ti.reply({content: `${i.user.username} has been added to the book club!`})\n})\n```\n\nLastly, let's turn off our collector. We will use **`console.log`** to output **`collected`**.\n\n```jsx\ncollector.on('end', c =\u003e {\n\tconsole.log('collected'\n})\n```\n\nResources:\n\n[Discord.js Collectors Guide](https://discordjs.guide/popular-topics/collectors.html#interaction-collectors)\n\n\n## Conditionally Disable a Custom Discord.js Button\n\nThere are two issues that require solving. Presently, when a user with the book club role clicks the button, they receive an error message. Additionally, even if submissions are closed, users can still click the button. To improve the user experience, I will add code to display a more appropriate message when someone clicks the button but already has the book club role. I will also disable the button once submissions are closed.\n\nTo handle the first issue, I will add an **`if`** statement to the **`filter`** function to check the user's roles. If the user already has the book club role, a hidden message will be sent to them using **`ephemeral`** to let them know they have already been added.\n\n```jsx\nconst filter = i =\u003e {\n\tif (interaction.guild.members.cache.get(i.user.id).roles.cache.has(bookClubRoleId) === true) {\n\t\ti.reply({content: `You've already been added to the book club.`, ephemeral: true})\n\t}\n\treturn interaction.guild.members.cache.get(i.user.id).roles.cache.has(bookClubRoleId) === false\n}\n```\n\nTo disable the button, I will create a new button using **`ActionRowBuilder`** and set the **`setDisabled(true)`** property to make it unclickable. Finally, I will use **`interaction.editReply()`** to update the original reply and add the new button.\n\n```jsx\nconst disabledButton = new ActionRowBuilder()\n\t.addComponents(\n\t\tnew ButtonBuilder()\n\t\t\t.setCustomId('primary')\n\t\t\t.setStyle(ButtonStyle.Primary)\n\t\t\t.setLabel('Submissions Closed')\n\t\t\t.setDisabled(true)\n\t);\n\n...\n\ncollector.on('end', c =\u003e {\n\tinteraction.editReply({embeds: [embedMessage], components: [disabledButton]})\n})\n```\n\nLastly, for additional information, I will log out the size of our collection.\n\n```jsx\ncollector.on('end', c =\u003e {\n\tinteraction.editReply({embeds: [embedMessage], components: [disabledButton]})\n\tconsole.log(`collected ${c.size}`)\n})\n```\n\n\n## Deploy a Discord.js Bot for Production\n\nTo deploy the bot in its finished state, I will create a new GitHub repository and push the code to it, making sure to ignore the **`node_modules`** directory and the **`.env`** file by adding them to the **`.gitignore`** file.\n\nFor deployment, I will use **[railway.app](http://railway.app/)**. If necessary, I will create an account and select **`start a new project`**, then choose my repository from the **`deploy from GitHub`** option. After adding the environment variables, I can deploy the bot!\n\n\n## Conclusion\n\nBuilding a Book Club Bot with Discord.js is a fun and challenging project that can help you hone your programming skills while providing a valuable tool for managing your book club. By following the steps outlined in this tutorial, you should now have a solid understanding of how to create a Discord bot, interact with the Discord API, and utilize various libraries such as Discord.js and Dotenv. From creating custom commands and buttons to handling interactions and deploying your bot, this tutorial has covered all the essential aspects of building a book club bot. So what are you waiting for? Grab your favorite programming language and start building your own book club bot today!\n\n### Resources List\n- [Discord.js' guide](https://discordjs.guide/)\n- [Discord.js discord channel](https://discord.com/invite/djs)\n- [Discord status page](https://discordstatus.com/)\n- [Discord Developer Portal](https://discord.com/developers/applications)\n- [Discord.js Slash Commands](https://discordjs.guide/creating-your-bot/slash-commands.html#before-you-continue)\n- [Bot Template Repo](https://github.com/lsminter/discord-bot-template)\n- [Discord timestamps table on GitHub](https://gist.github.com/LeviSnoot/d9147767abeef2f770e9ddcd91eb85aa)\n- [UNIX timestamp converter and definition](https://www.unixtimestamp.com/)\n- [Discord.js Button Guide](https://discordjs.guide/interactions/buttons.html#building-and-sending-buttons)\n- [Button Styles](https://discordjs.guide/interactions/buttons.html#button-styles)\n- [Discord.js Collectors Guide](https://discordjs.guide/popular-topics/collectors.html#interaction-collectors)\n- [railway.app](http://railway.app/)","slug":{"_type":"slug","current":"create-a-book-club-bot-using-discord-js-v14"},"title":"Create a Book Club Bot using Discord.js v14"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"create-a-book-club-bot-using-discord-js-v14"},"buildId":"x523rJhSpv55S3vAbYE-S","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>