{"pageProps":{"post":{"author":{"_createdAt":"2023-01-20T23:21:59Z","_id":"c87c5c26-aeb7-4a10-812d-98cb53801f40","_rev":"Jbh3e9W2SIs3qJeiZBiBWQ","_type":"author","_updatedAt":"2023-01-20T23:21:59Z","bio":[{"_key":"db9c4c531c02","_type":"block","children":[{"_key":"f311882b8511","_type":"span","marks":[],"text":"Author and creator of this blog."}],"markDefs":[],"style":"normal"}],"image":{"_type":"image","asset":{"_ref":"image-4685b1085a6d182cb91a1d85fd6878a604694ee6-1355x1799-jpg","_type":"reference"}},"name":"Lucas Minter","slug":{"_type":"slug","current":"lucas-minter"}},"body":"## Introduction:\n\nThis tutorial is based off of my course released on [egghead.io](https://egghead.io/courses/build-a-book-club-bot-with-discord-js-501f5be9).\n\nIn this tutorial, I will guide you through creating your first Discord bot. We will begin by setting up our bot in the Discord developer portal, followed by setting up the bot locally. I will teach you how to develop a basic chatbot, and then we will dive into creating slash commands with more detail. Finally, we will deploy the bot to ensure it runs continuously.\n\nI have found the following resources to be helpful while developing:\n\n- [Discord.js' guide](https://discordjs.guide/) on their website is an excellent resource for learning more about each topic covered in this tutorial.\n- If you have any questions you can't figure out, I highly encourage you to check out the [Discord.js discord channel](https://discord.com/invite/djs). However, please try to solve the problem yourself first. Accurately describing the issue and the attempted solutions is a great way to get a quick answer.\n- The [Discord status page](https://discordstatus.com/) is a useful tool to check for any Discord outages. If your bot isn't working and you can't find the issue, verifying that everything is running on Discord's end is a great debugging step.\n- \n\n## Create and Configure a Bot using the Discord Developer Portal\n\nTo get started, go to **[https://discord.com/developers/applications](https://discord.com/developers/applications)**. If you do not have an account, you will need to sign up for one. Once you're in, click \"New Application\" and name your bot.\n\nIn the navigation column on the left, click \"Bot,\" then click \"Add Bot.\" This will convert your application into a bot.\n\nNext, click on \"OAuth2,\" then \"URL Generator,\" and select \"bot\" to set the necessary permissions. The specific permissions required will depend on what you want your bot to do. Since we're creating a book club event bot, we need to grant it the following permissions: manage roles, manage channels, read messages/view channels, moderate members, send messages, manage messages, add reactions, and use slash commands. Copy the generated URL and add it to your Discord channel.\n\n\n## Send your first Discord.js Bot Event\n\nTo begin, create a directory and navigate to it using the command line. Then, run **`yarn init -y`** to generate the initial files. We will also need to install the following dependencies: discord.js, dotenv, and nodemon.\n\nAfter that, create a **`.env`** file to save some variables. In the Discord developer portal, we will need two variables: **`application id`**, which will be saved as **`CLIENT_ID`**, and a token that can be found by clicking \"Reset Token\" in the \"Bot\" section. Save the token in your **`.env`** file as **`TOKEN`**.\n\nNext, create a **`main.js`** file in the root of your directory and import the necessary packages:\n\n```jsx\nconst { Client, Intents } = require('discord.js');\nrequire('dotenv').config();\n```\n\nWe will then create a new client instance:\n\n```jsx\nconst client = new Client({ intents: [Intents.FLAGS.GUILDS] });\n```\n\nOnce we have created the client, it is common practice to log in to make sure the bot is working as intended:\n\n```jsx\nclient.once('ready', () => {\n  console.log(`Ready! Logged in as ${client.user.tag}`);\n});\n```\n\nWe can then log in to Discord with our client's token:\n\n```jsx\nclient.login(process.env.TOKEN);\n```\n\nLastly, in **`package.json`**, create a development script using nodemon:\n\n```json\n\"scripts\": {\n  \"dev\": \"nodemon main.js\"\n},\n```\n\nRun **`yarn dev`** to start your bot!\n\n\n## Create your first Discord.js Bot Message Command\n\nTo create your first message command, you need to add the necessary permissions via the **`GatewayIntentBits`**. Here is an example of how to set up the client with the required intents:\n\n```jsx\nconst client = new Client({ intents: [ GatewayIntentBits.Guilds, GatewayIntentBits.GuildMessages, GatewayIntentBits.MessageContent ]});\n```\n\nUsing **`client.on`**, the bot will check the messages sent in the server to see if they match up with the desired command name, and then reply to that command with some text. Here is an example:\n\n```jsx\nclient.on('messageCreate', (message) => {\n  if(message.content === 'hello'){\n    message.reply('world');\n  }\n});\n```\n\nIf you want to create a simple chatbot, you can keep checking the messages in your server with if/else statements and reply accordingly. However, if you want to create a more intricate bot, you'll want to use slash commands.\n\n\n## What are Slash Commands\n\nUsing if/else blocks to create a bot can become cluttered and hard to read as it becomes more complex. However, Slash Commands offer a solution by allowing you to separate commands into individual files and providing helpful configurations.\n\nAccording to the **[Discord.js tutorial](https://discordjs.guide/creating-your-bot/slash-commands.html)**, here are some advantages of using Slash Commands:\n\n- Integration with the Discord client interface.\n- Automatic command detection and parsing of associated options/arguments.\n- Typed argument inputs for command options, such as \"String\", \"User\", or \"Role\".\n- Validated or dynamic choices for command options.\n- In-channel private responses (ephemeral messages).\n- Pop-up form-style inputs for capturing additional information.\n\nTherefore, if you plan on creating a more complex bot, it is recommended to use Slash Commands to keep your code organized and manageable.\n\n\n## Setup Files for your first Discord.js Slash Command\n\nThanks to the Discord.js guide, we can use some of their files to set up our project completely for slash commands. While you can have these functions set up in your **`main.js`** file, it's much more readable to extract them into their own folder and files.\n\nHere are five files that I grabbed from the **[Discord.js guide](https://discordjs.guide/creating-your-bot/)** to run slash commands. I won't go into detail here, so you can either go through their documentation or watch my course on **[egghead.io](https://egghead.io/courses/build-a-book-club-bot-with-discord-js-501f5be9)**.\n\nYou can manually add the files listed, or you can **[clone the template](https://github.com/lsminter/discord-bot-template)** I created, fill out the **`.env`** file, and be ready for the next section.\n\n### Main.js\n\n```jsx\nconst fs = require('node:fs')\nconst path = require('node:path')\n\nconst { Client, GatewayIntentBits, Collection } = require('discord.js');\nrequire('dotenv').config()\n\nconst client = new Client({ intents: [ GatewayIntentBits.Guilds ]});\n\nclient.commands = new Collection();\n\nconst commandsPath = path.join(__dirname, 'commands');\nconst commandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.js'));\n\nfor (const file of commandFiles) {\n\tconst filePath = path.join(commandsPath, file);\n\tconst command = require(filePath);\n\tif ('data' in command && 'execute' in command) {\n\t\tclient.commands.set(command.data.name, command);\n\t} else {\n\t\tconsole.log(`[WARNING] The command at ${filePath} is missing a required \"data\" or \"execute\" property.`);\n\t}\n}\n\nconst eventsPath = path.join(__dirname, 'events');\nconst eventFiles = fs.readdirSync(eventsPath).filter(file => file.endsWith('.js'));\n\nfor (const file of eventFiles) {\n\tconst filePath = path.join(eventsPath, file);\n\tconst event = require(filePath);\n\tif (event.once) {\n\t\tclient.once(event.name, (...args) => event.execute(...args));\n\t} else {\n\t\tclient.on(event.name, (...args) => event.execute(...args));\n  }\n}\n\nclient.login(process.env.TOKEN);\n```\n\n### events/interactionCreate.js\n\n```jsx\nconst { Events } = require('discord.js');\n\nmodule.exports = {\n\tname: Events.InteractionCreate,\n\tasync execute(interaction) {\n\t\tif (!interaction.isChatInputCommand()) return;\n\n\t\tconst command = interaction.client.commands.get(interaction.commandName);\n\n\t\tif (!command) {\n\t\t\tconsole.error(`No command matching ${interaction.commandName} was found.`);\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tawait command.execute(interaction);\n\t\t} catch (error) {\n\t\t\tconsole.error(`Error executing ${interaction.commandName}`);\n\t\t\tconsole.error(error);\n\t\t}\n\t},\n};\n```\n\n### events/ready.js\n\n```jsx\nconst { Events } = require('discord.js');\n\nmodule.exports = {\n\tname: Events.ClientReady,\n\tonce: true,\n\texecute(client) {\n\t\tconsole.log(`Ready! Logged in as ${client.user.tag}`);\n\t},\n};\n```\n\n### deploy-commands.js\n\n```jsx\nconst { REST, Routes } = require('discord.js');\nrequire('dotenv').config()\nconst fs = require('node:fs');\n\nconst commands = [];\n// Grab all the command files from the commands directory you created earlier\nconst commandFiles = fs.readdirSync('./commands').filter(file => file.endsWith('.js'));\n\n// Grab the SlashCommandBuilder#toJSON() output of each command's data for deployment\nfor (const file of commandFiles) {\n\tconst command = require(`./commands/${file}`);\n\tcommands.push(command.data.toJSON());\n}\n\n// Construct and prepare an instance of the REST module\nconst rest = new REST({ version: '10' }).setToken(process.env.TOKEN);\n\n// and deploy your commands!\n(async () => {\n\ttry {\n\t\tconsole.log(`Started refreshing ${commands.length} application (/) commands.`);\n\n\t\t// The put method is used to fully refresh all commands in the guild with the current set\n\t\tconst data = await rest.put(\n\t\t\tRoutes.applicationGuildCommands(process.env.CLIENT_ID, process.env.GUILD_ID),\n\t\t\t{ body: commands },\n\t\t);\n\n\t\tconsole.log(`Successfully reloaded ${data.length} application (/) commands.`);\n\t} catch (error) {\n\t\t// And of course, make sure you catch and log any errors!\n\t\tconsole.error(error);\n\t}\n})();\n```\n\n### commands/ping.js\n\n```jsx\n\nconst { SlashCommandBuilder } = require('discord.js');\n\nmodule.exports = {\n\tdata: new SlashCommandBuilder()\n\t\t.setName('ping')\n\t\t.setDescription('Replies with Pong'),\n\tasync execute(interaction) {\n\t\tawait interaction.reply(`Pong!`);\n\t},\n};\n```\n\n\n## Create your first Discord.js Slash Command\n\nIf you have already cloned the repository, you should have the **`ping`** command set up. You can find the code for the file in the section above.\n\nTo create a slash command, you need two things: the **`data`** property and the **`execute`** method. The **`data`** property is the definition you give to your command and requires at least two fields, **`setName`** and **`setDescription`**. The **`execute`** method will contain the functionality that your event handler will run.\n\nDiscord.js Slash Commands are promise-based, so we will be using **`async/await`** in our **`execute`** method. If you ever encounter an error and are unsure why, double-checking that you are using **`async/await`** correctly is a good place to start.\n\nAfter creating the command, I will use the single-guild registration for my bot to register the command to my server using **`node deploy-commands.js`**. If your bot scales and is in multiple servers, you can register your commands across all servers, but that won't be necessary for this course. You only need to register your command once.\n\n\n## Receive and Respond to Input From Users with Discord.js Slash Commands\n\nLet's start by creating the book club command using slash commands. One of the main advantages of using slash commands is that we can prompt users for input using input fields. In this case, we'll prompt users to enter a book title using **`addStringOption`**, the number of people interested using **`addIntegerOption`**, and the deadline for submissions using another **`addIntegerOption`**. We can make these fields required by using **`setRequired`**.\n\nIn the **`execute`** method, we can retrieve the data entered by the user using **`getString`** and **`getInteger`** and store them in separate variables. We can also store the username of the user who executed the command in an **`author`** variable, which we can later use in our reply message using the **`reply`** method.\n\n### bookClub.js\n\n```jsx\nconst { SlashCommandBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, PermissionsBitField, ChannelType } = require('discord.js');\n\nmodule.exports = {\n  data: new SlashCommandBuilder()\n    .setName('bookclub')\n    .setDescription('Creates a new book club!')\n    .addStringOption(op =>\n      op.setName('book')\n        .setDescription('The book the book club is on')\n        .setRequired(true)\n    )\n    .addIntegerOption(op =>\n      op.setName('people')\n        .setDescription('How many people you want for the club')\n        .setRequired(true)\n    )\n    .addIntegerOption( op =>\n      op.setName('hours')\n        .setDescription('When, in hours, you want submissions closed')\n        .setRequired(true)\n    )\n    ,\n\n  execute(interaction) {\n\t\tconst book = interaction.options.getString('book')\n    const numOfPeople = interaction.options.getInteger('people')\n    const hours = interaction.options.getInteger('hours')\n\n\t\tconst author = interaction.member.user.username\n\n\t\tinteraction.reply(`${author} is looking for ${numOfPeople} people to run a book club on the book ${book}. Submissions end in ${hours} hours.`)\n\t}\n}\n\n```\n\n\n## Convert a Discord Slash Command Bot Response to an Embedded Message\n\nTo streamline bot responses, embedded messages are an effective tool. Firstly, I will generate an appropriate title for the book club by utilizing the user-provided book input. To distinguish between similar book clubs, appending the date to the title is a useful strategy.\n\n```jsx\nconst bookClub = book + ' Book Club ' + new Date().toDateString()\n```\n\nNext, I will create an object, which will contain the essential components for an embed message - the **`title`** and **`description`** of the book club.\n\n```jsx\nconst embedMessage = {\n\ttitle: bookClub,\n\tdescription: `${author} is going to run a book club on the book ${book}.`,\n}\n```\n\nFollowing this, a **`field`** can be added to display the required number of participants and the expiration of submissions. Although the **`inline`** format can be used for numerous fields, I will stick to regular fields, as there are only a few.\n\n```jsx\nconst embedMessage = {\n\ttitle: bookClub,\n\tdescription: `${author} is going to run a book club on the book ${book}.`,\n\tfields: [\n\t\t{\n\t\t\tname: 'Amount of people wanted',\n\t\t\tvalue: `${numOfPeople}`\n\t\t},\n\t\t{\n\t\t\tname: `Submissions close in ${hours} hours`,\n\t\t\tvalue: `Time runs out in: ${hours} hours`\n\t\t}\n\t]\n}\n```\n\nFinally, I will respond to the interaction and include the embed message.\n\n```jsx\ninteraction.reply({ embeds: [embedMessage] })\n```\n\n\n## Display relative time in a Discord.js Embedded Message\n\nTo make it easier for our users, Discord provides us with a useful function based on the UNIX timestamp. With this, we can display the time relative to the user's location in Discord. I'll convert the number of hours given by the user into a UNIX timestamp and then use **`<t:${hours}:R>`** to show the relative time to the user.\n\n```jsx\nconst hours = interaction.options.getInteger('hours')\nconst waitTimeInSeconds = (hours * 60) * 60\nconst timeExpiresAt = Math.floor(new Date().getTime() / 1000) + waitTimeInSeconds\n\n...\n\n{\n\tname: `Submissions close at <t:${timeExpiresAt}:f>`,\n\tvalue: `Time runs out in: <t:${timeExpiresAt}:R>`\n}\n```\n\nThere are other ways to display time to our users, and you can find them in the Discord timestamps table on GitHub, as well as more information on the UNIX timestamp.\n\nResources:\n\n**[Discord timestamps table on GitHub](https://gist.github.com/LeviSnoot/d9147767abeef2f770e9ddcd91eb85aa)**\n\n**[UNIX timestamp converter and definition](https://www.unixtimestamp.com/)**\n\n\n## Create Custom Discord.js Buttons with ActionRowBuilder and ButtonBuilder\n\nTo allow users to interact with the embedded message and join the book club, a button needs to be created. The following code imports necessary components and sets up a button with three fields:\n\n```jsx\nconst { \n\tSlashCommandBuilder, \n\tActionRowBuilder, \n\tButtonBuilder, \n\tButtonStyle, \n\tPermissionsBitField,\n\tChannelType\n} = require('discord.js');\n\nconst row = new ActionRowBuilder()\n\t.addComponents(\n\t\tnew ButtonBuilder()\n\t\t\t.setCustomId('primary')\n\t\t\t.setStyle(ButtonStyle.Primary)\n\t\t\t.setEmoji('👍')\n\t);\n```\n\nTo display the button, it needs to be added as a component to the embedded message object:\n\n```jsx\ninteraction.reply({ embeds: [embedMessage], components: [row]})\n```\n\nResources:\n\n[Discord.js Button Guide](https://discordjs.guide/interactions/buttons.html#building-and-sending-buttons)\n\n[Button Styles](https://discordjs.guide/interactions/buttons.html#button-styles)\n\n\n## Create Dynamic Channels and Roles\n\nIn order to ensure that only book club members can view the club channel, we have to create a new channel and a role that will be applied to that channel.\n\nWe begin by creating the role for the book club with a name of our choosing and setting the required permissions to view channels and send messages using the following code snippet:\n\n```jsx\ninteraction.guild.roles.create({ \n\tname: `${bookClub}`,\n\tpermissions: [\n\t\tPermissionsBitField.Flags.ViewChannel,\n\t\tPermissionsBitField.Flags.SendMessages\n\t]\n})\n```\n\nThen, we get the role ID using **`interaction.guild.roles.cache.find()`** method, as shown below:\n\n```jsx\nconst bookClubRoleId = interaction.guild.roles.cache.find(r => r.name === bookClub).id\n```\n\nNext, we create the text channel and set permission overwrites to deny access to everyone except members of the book club. This is achieved using the following code snippet:\n\n```jsx\ninteraction.guild.channels.create({\n\tname: `${bookClub}`,\n\ttype: ChannelType.GuildText,\n\tpermissionOverwrites: [\n\t\t{\n\t\t\tid: interaction.guild.id,\n\t\t\tdeny: [PermissionsBitField.Flags.ViewChannel]\n\t\t},\n\t\t{\n\t\t\tid: bookClubRoleId,\n\t\t\tallow:[\n\t\t\t\tPermissionsBitField.Flags.SendMessages,\n\t\t\t\tPermissionsBitField.Flags.ViewChannel\n\t\t\t]\n\t\t}\n\t]\n})\n```\n\nFinally, we need to add **`async`** to the **`execute`** function and use **`await`** for the interactions, as Discord.js is promise-based. The modified code looks like this:\n\n```jsx\nasync execute(interaction) {\n\nawait interaction.reply({ embeds: [embedMessage], components: [row]})\n\nawait interaction.guild.roles.create({\n\nconst bookClubRoleId = await interaction.guild.roles.cache.find(r => r.name === bookClub).id\n\nawait interaction.guild.channels.create({\n```\n\nWe do this because Discord.js is promise-based, and without adding async/await, the calls might work occasionally, but they will not work properly all of the time.\n\n\n## Add Roles to Users using a Discord.js Collector\n\nCollectors are essential to gather information from users, and there are various types of collectors you can utilize. Before we get started, we must save our embedded message to a variable so we can attach a collector to it later on.\n\n```jsx\nconst finishedEmbedMessage = await interaction.reply({ embeds: [embedMessage], components: [row]})\n```\n\nSince we are using a button component on a message, we will use the **`createMessageComponentCollector`** collector.\n\nThe collector requires three fields: a **`filter`** to verify if users do not have the book club role.\n\n```jsx\nconst filter = i => {\n\treturn interaction.guild.members.cache.get(i.user.id).roles.cache.has(bookClubRoleId) === false\n}\n```\n\n**`max`** to specify the maximum number of items we want our collector to collect, and **`time`** to turn off the collector after a certain amount of time if we do not reach the maximum. We will need to convert the hours into milliseconds for the **`time`** variable.\n\n```jsx\nconst waitTimeInMilliseconds = waitTimeInSeconds * 1000\n\nconst collector = finishedEmbedMessage.createMessageComponentCollector({ filter, max: numOfPeople, time: waitTimeInMilliseconds})\n```\n\nNow, let's enable our collector. Inside this function is where we will add the role to our users. First, let us retrieve the ID of our user and store it in a variable: **`interaction.guild.members.cache.get(i.user.id)`**. With that ID, we can then add the book club role using the book club role ID.\n\nOnce that is complete, we want to send a message to ensure our users are aware that they were added to the book club. We will use a simple reply to display **`username has been added to the book club!`.**\n\n```jsx\ncollector.on('collect', i => {\n\tconst userById = interaction.guild.members.cache.get(i.user.id)\n\tuserById.roles.add(bookClubRoleId)\n\ti.reply({content: `${i.user.username} has been added to the book club!`})\n})\n```\n\nLastly, let's turn off our collector. We will use **`console.log`** to output **`collected`**.\n\n```jsx\ncollector.on('end', c => {\n\tconsole.log('collected'\n})\n```\n\nResources:\n\n[Discord.js Collectors Guide](https://discordjs.guide/popular-topics/collectors.html#interaction-collectors)\n\n\n## Conditionally Disable a Custom Discord.js Button\n\nThere are two issues that require solving. Presently, when a user with the book club role clicks the button, they receive an error message. Additionally, even if submissions are closed, users can still click the button. To improve the user experience, I will add code to display a more appropriate message when someone clicks the button but already has the book club role. I will also disable the button once submissions are closed.\n\nTo handle the first issue, I will add an **`if`** statement to the **`filter`** function to check the user's roles. If the user already has the book club role, a hidden message will be sent to them using **`ephemeral`** to let them know they have already been added.\n\n```jsx\nconst filter = i => {\n\tif (interaction.guild.members.cache.get(i.user.id).roles.cache.has(bookClubRoleId) === true) {\n\t\ti.reply({content: `You've already been added to the book club.`, ephemeral: true})\n\t}\n\treturn interaction.guild.members.cache.get(i.user.id).roles.cache.has(bookClubRoleId) === false\n}\n```\n\nTo disable the button, I will create a new button using **`ActionRowBuilder`** and set the **`setDisabled(true)`** property to make it unclickable. Finally, I will use **`interaction.editReply()`** to update the original reply and add the new button.\n\n```jsx\nconst disabledButton = new ActionRowBuilder()\n\t.addComponents(\n\t\tnew ButtonBuilder()\n\t\t\t.setCustomId('primary')\n\t\t\t.setStyle(ButtonStyle.Primary)\n\t\t\t.setLabel('Submissions Closed')\n\t\t\t.setDisabled(true)\n\t);\n\n...\n\ncollector.on('end', c => {\n\tinteraction.editReply({embeds: [embedMessage], components: [disabledButton]})\n})\n```\n\nLastly, for additional information, I will log out the size of our collection.\n\n```jsx\ncollector.on('end', c => {\n\tinteraction.editReply({embeds: [embedMessage], components: [disabledButton]})\n\tconsole.log(`collected ${c.size}`)\n})\n```\n\n\n## Deploy a Discord.js Bot for Production\n\nTo deploy the bot in its finished state, I will create a new GitHub repository and push the code to it, making sure to ignore the **`node_modules`** directory and the **`.env`** file by adding them to the **`.gitignore`** file.\n\nFor deployment, I will use **[railway.app](http://railway.app/)**. If necessary, I will create an account and select **`start a new project`**, then choose my repository from the **`deploy from GitHub`** option. After adding the environment variables, I can deploy the bot!\n\n\n## Conclusion\n\nBuilding a Book Club Bot with Discord.js is a fun and challenging project that can help you hone your programming skills while providing a valuable tool for managing your book club. By following the steps outlined in this tutorial, you should now have a solid understanding of how to create a Discord bot, interact with the Discord API, and utilize various libraries such as Discord.js and Dotenv. From creating custom commands and buttons to handling interactions and deploying your bot, this tutorial has covered all the essential aspects of building a book club bot. So what are you waiting for? Grab your favorite programming language and start building your own book club bot today!\n\n### Resources List\n- [Discord.js' guide](https://discordjs.guide/)\n- [Discord.js discord channel](https://discord.com/invite/djs)\n- [Discord status page](https://discordstatus.com/)\n- [Discord Developer Portal](https://discord.com/developers/applications)\n- [Discord.js Slash Commands](https://discordjs.guide/creating-your-bot/slash-commands.html#before-you-continue)\n- [Bot Template Repo](https://github.com/lsminter/discord-bot-template)\n- [Discord timestamps table on GitHub](https://gist.github.com/LeviSnoot/d9147767abeef2f770e9ddcd91eb85aa)\n- [UNIX timestamp converter and definition](https://www.unixtimestamp.com/)\n- [Discord.js Button Guide](https://discordjs.guide/interactions/buttons.html#building-and-sending-buttons)\n- [Button Styles](https://discordjs.guide/interactions/buttons.html#button-styles)\n- [Discord.js Collectors Guide](https://discordjs.guide/popular-topics/collectors.html#interaction-collectors)\n- [railway.app](http://railway.app/)","slug":{"_type":"slug","current":"create-a-book-club-bot-using-discord-js-v14"},"title":"Create a Book Club Bot using Discord.js v14"}},"__N_SSG":true}