{"pageProps":{"post":{"author":{"_createdAt":"2023-01-20T23:21:59Z","_id":"c87c5c26-aeb7-4a10-812d-98cb53801f40","_rev":"Jbh3e9W2SIs3qJeiZBiBWQ","_type":"author","_updatedAt":"2023-01-20T23:21:59Z","bio":[{"_key":"db9c4c531c02","_type":"block","children":[{"_key":"f311882b8511","_type":"span","marks":[],"text":"Author and creator of this blog."}],"markDefs":[],"style":"normal"}],"image":{"_type":"image","asset":{"_ref":"image-4685b1085a6d182cb91a1d85fd6878a604694ee6-1355x1799-jpg","_type":"reference"}},"name":"Lucas Minter","slug":{"_type":"slug","current":"lucas-minter"}},"body":"## WIP\nMake sure to talk about the discord channel for discord.js and their great documentation. You're probably going to want to create a bot channel in your server to do all of your testing since you'll probably be spamming it a good bit while testing. \n\n## Initial Files Setup\ndiscord.js v14 requires Node v16.9.0 or higher.\nCreate a project folder - `yarn init`\ninstall `discord.js` (I'm using v14.7.1), `nodemon` for development, and `dotenv` for environment variables\ncreate a `.env` file, we are going to store some variables there in a sec\nCreate a `.gitignore` file with node_modules and `.env` to make sure those don't get uploaded\n\n## Setup application on discord.com\nNavigate to https://discord.com/developers/applications\nYou'll need to sign up with an account if you have one\nClick new application\nName your bot\n- Save `application id` as `CLIENT_ID` in your `.env` file\n\nClick on bot\nClick `Add Bot`\nClick `Reset Token` and save that in your `.env` file as `TOKEN`. \n- Make sure to never show your token. Anyone will be able to use that to completely destroy the servers your bot is in. \nClick on `OAuth2` then `URL Generator`\nSelect `bot` then the permissions you want. \n- This all depends on what you plan on having your bot do, since this is a book club event bot, we need it to manage roles, manage channels, read messages/view channels, moderate members, send messages, manage messages, add reactions, and use slash commands. \nCopy the generated url and add it to your discord channel. \n\n## Logging in as your bot\nCreate a `main.js` file\nAdd the necessary imports:\n```js\nconst { Client, Events, GatewayIntentBits } = require('discord.js');\nrequire('dotenv').config()\n```\nCreate a new client instance:\n```js\nconst client = new Client({ intents: [GatewayIntentBits.Guilds] });\n```\nWith our client created, it's common practice to have your bot log once to make sure that it is working as intended:\n```js\nclient.once(Events.ClientReady, c => {\n  console.log(`Ready! Logged in as ${c.user.tag}`);\n})\n```\nLog into discord with your client's token:\n```js\nclient.login(process.env.TOKEN)\n```\nIn `package.json`, create a dev script using nodemon:\n```json\n\"dev\": \"nodemon main.js\"\n```\nRun `yarn dev` to see your bot start!\n\n## First command\nA simple first command is just a bot that replies to a specific message. At the bottom of `main.js`, we create our message command:\n```js\nclient.on('messageCreate', (message) => {\n\n})\n```\n`messageCreate` tells the bot that it's going to be a simple message command. Inside of that, we create an `if` block to check if the content of a message is exactly what we are looking for and then reply to that message. \n```js\nclient.on('messageCreate', (message) => {\n  if(message.content === 'hello'){\n    message.reply('world')\n  }\n})\n```\n\n## What are Slash Commands\nThe above is a good way to make a bot if it's going to be small and simple. The more complex your bot is, the more if/else blocks there are going to be. Your `main.js` file will get cluttered and be hard to read.\n\nSlash Commands allow you to separate our your commands into individual files as well as add some nice configurations that make creating commands simpler. \n\n(Taken from the discord tutorial)\n- Integration with the Discord client interface.\n- Automatic command detection and parsing of the associated options/arguments.\n- Typed argument inputs for command options, e.g. \"String\", \"User\", or \"Role\".\n- Validated or dynamic choices for command options.\n- In-channel private responses (ephemeral messages).\n- Pop-up form-style inputs for capturing additional information.\n\n## Slash Command File\nMake a new file called `commands/hello.js`.\nAdd the required imports for simple `hello world` command\n```js\nconst {SlashCommandBuilder} = require('discord.js');\n```\nExport the command:\n```js\nmodule.exports = {\n}\n```\nCreate the slash command. The `data` property will tell discord what the definition of our command is:\n```js\nmodule.exports = {\n  data: new SlashCommandBuilder()\n}\n```\nThe SlashCommandBuilder requires at least two things, the name of the command and a description.\n```js\nmodule.exports = {\n  data: new SlashCommandBuilder()\n    .setName('Hello')\n    .setDescription('Replies with World')\n}\n```\nNow we want to add code to our command. The `execute` method contains the code that the command is going to run:\n```js\nmodule.exports = {\n  data: new SlashCommandBuilder()\n    .setName('Hello')\n    .setDescription('Replies with World')\n  async execute(interaction) {\n    await interaction.reply('World!');\n  }\n}\n```\n\n## Load commands on startup\nIn `main.js`, we are going to use [`path`](https://nodejs.org/api/path.html) and [`fs`](https://nodejs.org/api/fs.html) from node to access the command files. We are also going to import `Collection` from discord.js\n```js\nconst fs = require('node:fs');\nconst path = require('node:path');\nconst { Client, Events, GatewayIntentBits, Collection } = require('discord.js');\n```\nNow we will want to attach `commands` to our client so that we can access those commands in other files:\n```js\nclient.commands = new Collection();\n```\n`new Collection()` here is mapping over our command files and giving our client access to those commands. \nI'm going to paste in some code from the discord.js guide to dynamically retrieve those command files with a little error handling:\n```js\nconst commandsPath = path.join(__dirname, 'commands');\nconst commandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.js'));\n\nfor (const file of commandFiles) {\n\tconst filePath = path.join(commandsPath, file);\n\tconst command = require(filePath);\n\tif ('data' in command && 'execute' in command) {\n\t\tclient.commands.set(command.data.name, command);\n\t} else {\n\t\tconsole.log(`[WARNING] The command at ${filePath} is missing a required \"data\" or \"execute\" property.`);\n\t}\n}\n```\nNow that we have those command files, we are going to call the command's `.execute()` method and pass in the `interaction` variable as its argument. Going to paste in a little more code for that as well:\n```js\nclient.on(Events.InteractionCreate, async interaction => {\n\tif (!interaction.isChatInputCommand()) return;\n\n\tconst command = interaction.client.commands.get(interaction.commandName);\n\n\tif (!command) {\n\t\tconsole.error(`No command matching ${interaction.commandName} was found.`);\n\t\treturn;\n\t}\n\n\ttry {\n\t\tawait command.execute(interaction);\n\t} catch (error) {\n\t\tconsole.error(error);\n\t\tawait interaction.reply({ content: 'There was an error while executing this command!', ephemeral: true });\n\t}\n});\n```\n\n## Register Commands to Discord\nThis is where we need all three of our environment variables, `TOKEN`, `CLIENT_ID`, and now we need our server's id and save that in our `.env` file as `GUILD_ID`. \nTo get our server's id, in your Discord application, go to settings then Advanced and turn on `Developer Mode`. This will give you access to a lot of nice tools to make creating your bot easier. \nOne that we are going to use right now is right click on your server and `Copy ID`. \n\nNow we are going to create a file called `deploy-commands.js`. Here we are going to paste in the last bit of code that discord.js gives us on their guide. \n```js\nconst { REST, Routes } = require('discord.js');\nrequire('dotenv').config()\nconst fs = require('node:fs');\n\nconst commands = [];\nconst commandFiles = fs.readdirSync('./commands').filter(file => file.endsWith('.js'));\n\nfor (const file of commandFiles) {\n\tconst command = require(`./commands/${file}`);\n\tcommands.push(command.data.toJSON());\n}\n\nconst rest = new REST({ version: '10' }).setToken(process.env.TOKEN);\n\n(async () => {\n\ttry {\n\t\tconsole.log(`Started refreshing ${commands.length} application (/) commands.`);\n\n\t\tconst data = await rest.put(\n\t\t\tRoutes.applicationGuildCommands(process.env.CLIENT_ID, process.env.GUILD_ID),\n\t\t\t{ body: commands },\n\t\t);\n\n\t\tconsole.log(`Successfully reloaded ${data.length} application (/) commands.`);\n\t} catch (error) {\n\t\tconsole.error(error);\n\t}\n})();\n```\nThe last thing we are going to do before we run our commands is create a deploy command in `package.json`. \n```json\n\"deploy\": \"node deploy-commands.js\"\n```\nWe are going to run that command `yarn deploy` and if everything was done correctly, you should see `Successfully reloaded 2 application (/) commands.` logged out in your terminal.\nNow we can run our bot with `yarn dev` and try out our first slash command!\n\n## Refactoring\nWe would like to have all of our interactions out of our `main.js` file. The last thing we have in there is: \n```js\nclient.once(Events.ClientReady, c => {\n\tconsole.log(`Ready! Logged in as ${c.user.tag}`);\n});\n```\nWe would like to do the same treatment to our `Events` as we did for our `Commands`. Events can clutter up our main file and make it hard to read. \nWe will create a new directory called `Event` and add two files, `ready.js` and `interactionCreate.js`. \nSimilar to our first slash command, we will create our login event in `ready.js`:\n```js\nconst { Events } = require('discord.js');\n\nmodule.exports = {\n\tname: Events.ClientReady,\n\tonce: true,\n\texecute(client) {\n\t\tconsole.log(`Ready! Logged in as ${client.user.tag}`);\n\t},\n};\n```\nWe will also move over `Events.InteractionCreate` from our main file to `interactionCreate.js`:\n```js\nconst { Events } = require('discord.js');\n\nmodule.exports = {\n\tname: Events.InteractionCreate,\n\tasync execute(interaction) {\n\t\tif (!interaction.isChatInputCommand()) return;\n\n\t\tconst command = interaction.client.commands.get(interaction.commandName);\n\n\t\tif (!command) {\n\t\t\tconsole.error(`No command matching ${interaction.commandName} was found.`);\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tawait command.execute(interaction);\n\t\t} catch (error) {\n\t\t\tconsole.error(`Error executing ${interaction.commandName}`);\n\t\t\tconsole.error(error);\n\t\t}\n\t},\n};\n```\nNow in our main file, to be able to read those event files, we will do almost exactly what we did to be able to read the command files: \n```js\nconst eventsPath = path.join(__dirname, 'events');\nconst eventFiles = fs.readdirSync(eventsPath).filter(file => file.endsWith('.js'));\n\nfor (const file of eventFiles) {\n\tconst filePath = path.join(eventsPath, file);\n\tconst event = require(filePath);\n\tif (event.once) {\n\t\tclient.once(event.name, (...args) => event.execute(...args));\n\t} else {\n\t\tclient.on(event.name, (...args) => event.execute(...args));\n\t}\n}\n```\nRun the bot to double check that it's working and you should see `Ready! Logged in as Book Club Bot 2.0#5180` printed out in your console. \n\nNow we are done with the setup and can start creating our Book Club Bot!\n\n## Data Setup for book club bot\nCreate a new file for our book club bot in our commands directory named `bookClub.js`. We'll start off by importing the `SlashCommandBuilder` and adding the base code for our `data` property:\n```js\nconst { SlashCommandBuilder } = require('discord.js');\n\nmodule.exports = {\n  data: new SlashCommandBuilder()\n    .setName('book-club')\n    .setDescription('Creates a new book club!')\n}\n```\nNow we get to implement one of the really cool features of discord.js which is `options`.  If we specify the type of option to be string, `addStringOption`, when the user uses the command, it will prompt them for an input of type `any` and it will convert it to a string. We are going to be using `addStringOption` and `addIntegerOption` to get the name of the book, number of people wanted, and when the submissions are closed. \n```js\nconst { SlashCommandBuilder } = require('discord.js');\n\nmodule.exports = {\n\tdata: new SlashCommandBuilder()\n  .setName('book-club')\n\t.setDescription('Creates a new book club!')\n\t.addStringOption(op =>\n\t\top.setName('book')\n\t\t\t.setDescription('The book the book club is on')\n\t\t\t.setRequired(true))\n\t.addIntegerOption(option =>\n\t\toption.setName('people')\n\t\t\t.setDescription('How many people you want for the club')\n\t\t\t.setRequired(true))\n\t.addIntegerOption(option => \n\t\toption.setName('hours')\n\t\t\t.setDescription('When, in hours, you want enrolment closed')\n\t\t\t.setRequired(true)),\n}\n```\n\nNow we can get to work on writing what is going to happen with those inputs in our `execute`. Discord.js is promise based so whenever you are fetching/sending with discord, you're going to almost always need `await`. \n\n```js\nconst book = interaction.options.getString('book');\n\t\tconst bookClub = book + ' Book Club ' + moment().format('MMMM Do YYYY')\n\n\t\tconst numOfPeople = interaction.options.getInteger('people')\n\n\t\tconst hours = interaction.options.getInteger('hours')\n\t\tconst waitTimeInSeconds = (hours * 60) * 60 \n\t\tconst today = new Date()\n\t\tconst todayUNIX = Math.floor(today.getTime() / 1000)\n\t\tconst timeExpiresAt = todayUNIX + waitTimeInSeconds\n```","publishedAt":"2023-01-21T03:30:00.000Z","slug":{"_type":"slug","current":"how-to-make-a-discord-bot"},"title":"How to make a discord bot"}},"__N_SSG":true}