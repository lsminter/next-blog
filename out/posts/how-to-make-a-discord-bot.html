<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2491e22649e2b558.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2491e22649e2b558.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-45f9f9587e6c08e1.js" defer=""></script><script src="/_next/static/chunks/framework-894baf07b784aec6.js" defer=""></script><script src="/_next/static/chunks/main-63854ee67f4963c5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-3e55c7d5a6a95d75.js" defer=""></script><script src="/_next/static/chunks/963-cdd01fa158147eb6.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-be7f2353613d4a3f.js" defer=""></script><script src="/_next/static/EnhcvAUsi813Z5H5Qa9-b/_buildManifest.js" defer=""></script><script src="/_next/static/EnhcvAUsi813Z5H5Qa9-b/_ssgManifest.js" defer=""></script><script src="/_next/static/EnhcvAUsi813Z5H5Qa9-b/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div class="h-max px-4 sm:px-12 bg-background"><header class="flex justify-between"><div class="flex"><a class="hover:text-blue-600 pt-2" href="/">Lucas Minter</a></div><div class="pt-2"><a class="hover:text-blue-600 px-2" href="/Framer-Motion">Framer Motion</a><a class="hover:text-blue-600 px-2" href="/posts">Posts</a><a class="hover:text-blue-600 pl-2" href="/">Home</a></div></header><div class="prose mx-auto max-w-4x1"><h1 class="text-center text-3xl">How to make a discord bot</h1><h4 class="my-4 text-center">by <!-- -->Lucas Minter</h4><p class="my-4 text-center"><a href="/posts">← go back to all posts</a></p><article><h2 id="wip">WIP</h2>
<p>Make sure to talk about the discord channel for discord.js and their great documentation. You&#39;re probably going to want to create a bot channel in your server to do all of your testing since you&#39;ll probably be spamming it a good bit while testing. </p>
<h2 id="initial-files-setup">Initial Files Setup</h2>
<p>discord.js v14 requires Node v16.9.0 or higher.
Create a project folder - <code>yarn init</code>
install <code>discord.js</code> (I&#39;m using v14.7.1), <code>nodemon</code> for development, and <code>dotenv</code> for environment variables
create a <code>.env</code> file, we are going to store some variables there in a sec
Create a <code>.gitignore</code> file with node_modules and <code>.env</code> to make sure those don&#39;t get uploaded</p>
<h2 id="setup-application-on-discordcom">Setup application on discord.com</h2>
<p>Navigate to <a href="https://discord.com/developers/applications">https://discord.com/developers/applications</a>
You&#39;ll need to sign up with an account if you have one
Click new application
Name your bot</p>
<ul>
<li>Save <code>application id</code> as <code>CLIENT_ID</code> in your <code>.env</code> file</li>
</ul>
<p>Click on bot
Click <code>Add Bot</code>
Click <code>Reset Token</code> and save that in your <code>.env</code> file as <code>TOKEN</code>. </p>
<ul>
<li>Make sure to never show your token. Anyone will be able to use that to completely destroy the servers your bot is in. 
Click on <code>OAuth2</code> then <code>URL Generator</code>
Select <code>bot</code> then the permissions you want. </li>
<li>This all depends on what you plan on having your bot do, since this is a book club event bot, we need it to manage roles, manage channels, read messages/view channels, moderate members, send messages, manage messages, add reactions, and use slash commands. 
Copy the generated url and add it to your discord channel.</li>
</ul>
<h2 id="logging-in-as-your-bot">Logging in as your bot</h2>
<p>Create a <code>main.js</code> file
Add the necessary imports:</p>
<pre><code class="language-js">const { Client, Events, GatewayIntentBits } = require(&#39;discord.js&#39;);
require(&#39;dotenv&#39;).config()
</code></pre>
<p>Create a new client instance:</p>
<pre><code class="language-js">const client = new Client({ intents: [GatewayIntentBits.Guilds] });
</code></pre>
<p>With our client created, it&#39;s common practice to have your bot log once to make sure that it is working as intended:</p>
<pre><code class="language-js">client.once(Events.ClientReady, c =&gt; {
  console.log(`Ready! Logged in as ${c.user.tag}`);
})
</code></pre>
<p>Log into discord with your client&#39;s token:</p>
<pre><code class="language-js">client.login(process.env.TOKEN)
</code></pre>
<p>In <code>package.json</code>, create a dev script using nodemon:</p>
<pre><code class="language-json">&quot;dev&quot;: &quot;nodemon main.js&quot;
</code></pre>
<p>Run <code>yarn dev</code> to see your bot start!</p>
<h2 id="first-command">First command</h2>
<p>A simple first command is just a bot that replies to a specific message. At the bottom of <code>main.js</code>, we create our message command:</p>
<pre><code class="language-js">client.on(&#39;messageCreate&#39;, (message) =&gt; {

})
</code></pre>
<p><code>messageCreate</code> tells the bot that it&#39;s going to be a simple message command. Inside of that, we create an <code>if</code> block to check if the content of a message is exactly what we are looking for and then reply to that message. </p>
<pre><code class="language-js">client.on(&#39;messageCreate&#39;, (message) =&gt; {
  if(message.content === &#39;hello&#39;){
    message.reply(&#39;world&#39;)
  }
})
</code></pre>
<h2 id="what-are-slash-commands">What are Slash Commands</h2>
<p>The above is a good way to make a bot if it&#39;s going to be small and simple. The more complex your bot is, the more if/else blocks there are going to be. Your <code>main.js</code> file will get cluttered and be hard to read.</p>
<p>Slash Commands allow you to separate our your commands into individual files as well as add some nice configurations that make creating commands simpler. </p>
<p>(Taken from the discord tutorial)</p>
<ul>
<li>Integration with the Discord client interface.</li>
<li>Automatic command detection and parsing of the associated options/arguments.</li>
<li>Typed argument inputs for command options, e.g. &quot;String&quot;, &quot;User&quot;, or &quot;Role&quot;.</li>
<li>Validated or dynamic choices for command options.</li>
<li>In-channel private responses (ephemeral messages).</li>
<li>Pop-up form-style inputs for capturing additional information.</li>
</ul>
<h2 id="slash-command-file">Slash Command File</h2>
<p>Make a new file called <code>commands/hello.js</code>.
Add the required imports for simple <code>hello world</code> command</p>
<pre><code class="language-js">const {SlashCommandBuilder} = require(&#39;discord.js&#39;);
</code></pre>
<p>Export the command:</p>
<pre><code class="language-js">module.exports = {
}
</code></pre>
<p>Create the slash command. The <code>data</code> property will tell discord what the definition of our command is:</p>
<pre><code class="language-js">module.exports = {
  data: new SlashCommandBuilder()
}
</code></pre>
<p>The SlashCommandBuilder requires at least two things, the name of the command and a description.</p>
<pre><code class="language-js">module.exports = {
  data: new SlashCommandBuilder()
    .setName(&#39;Hello&#39;)
    .setDescription(&#39;Replies with World&#39;)
}
</code></pre>
<p>Now we want to add code to our command. The <code>execute</code> method contains the code that the command is going to run:</p>
<pre><code class="language-js">module.exports = {
  data: new SlashCommandBuilder()
    .setName(&#39;Hello&#39;)
    .setDescription(&#39;Replies with World&#39;)
  async execute(interaction) {
    await interaction.reply(&#39;World!&#39;);
  }
}
</code></pre>
<h2 id="load-commands-on-startup">Load commands on startup</h2>
<p>In <code>main.js</code>, we are going to use <a href="https://nodejs.org/api/path.html"><code>path</code></a> and <a href="https://nodejs.org/api/fs.html"><code>fs</code></a> from node to access the command files. We are also going to import <code>Collection</code> from discord.js</p>
<pre><code class="language-js">const fs = require(&#39;node:fs&#39;);
const path = require(&#39;node:path&#39;);
const { Client, Events, GatewayIntentBits, Collection } = require(&#39;discord.js&#39;);
</code></pre>
<p>Now we will want to attach <code>commands</code> to our client so that we can access those commands in other files:</p>
<pre><code class="language-js">client.commands = new Collection();
</code></pre>
<p><code>new Collection()</code> here is mapping over our command files and giving our client access to those commands. 
I&#39;m going to paste in some code from the discord.js guide to dynamically retrieve those command files with a little error handling:</p>
<pre><code class="language-js">const commandsPath = path.join(__dirname, &#39;commands&#39;);
const commandFiles = fs.readdirSync(commandsPath).filter(file =&gt; file.endsWith(&#39;.js&#39;));

for (const file of commandFiles) {
    const filePath = path.join(commandsPath, file);
    const command = require(filePath);
    if (&#39;data&#39; in command &amp;&amp; &#39;execute&#39; in command) {
        client.commands.set(command.data.name, command);
    } else {
        console.log(`[WARNING] The command at ${filePath} is missing a required &quot;data&quot; or &quot;execute&quot; property.`);
    }
}
</code></pre>
<p>Now that we have those command files, we are going to call the command&#39;s <code>.execute()</code> method and pass in the <code>interaction</code> variable as its argument. Going to paste in a little more code for that as well:</p>
<pre><code class="language-js">client.on(Events.InteractionCreate, async interaction =&gt; {
    if (!interaction.isChatInputCommand()) return;

    const command = interaction.client.commands.get(interaction.commandName);

    if (!command) {
        console.error(`No command matching ${interaction.commandName} was found.`);
        return;
    }

    try {
        await command.execute(interaction);
    } catch (error) {
        console.error(error);
        await interaction.reply({ content: &#39;There was an error while executing this command!&#39;, ephemeral: true });
    }
});
</code></pre>
<h2 id="register-commands-to-discord">Register Commands to Discord</h2>
<p>This is where we need all three of our environment variables, <code>TOKEN</code>, <code>CLIENT_ID</code>, and now we need our server&#39;s id and save that in our <code>.env</code> file as <code>GUILD_ID</code>. 
To get our server&#39;s id, in your Discord application, go to settings then Advanced and turn on <code>Developer Mode</code>. This will give you access to a lot of nice tools to make creating your bot easier. 
One that we are going to use right now is right click on your server and <code>Copy ID</code>. </p>
<p>Now we are going to create a file called <code>deploy-commands.js</code>. Here we are going to paste in the last bit of code that discord.js gives us on their guide. </p>
<pre><code class="language-js">const { REST, Routes } = require(&#39;discord.js&#39;);
require(&#39;dotenv&#39;).config()
const fs = require(&#39;node:fs&#39;);

const commands = [];
const commandFiles = fs.readdirSync(&#39;./commands&#39;).filter(file =&gt; file.endsWith(&#39;.js&#39;));

for (const file of commandFiles) {
    const command = require(`./commands/${file}`);
    commands.push(command.data.toJSON());
}

const rest = new REST({ version: &#39;10&#39; }).setToken(process.env.TOKEN);

(async () =&gt; {
    try {
        console.log(`Started refreshing ${commands.length} application (/) commands.`);

        const data = await rest.put(
            Routes.applicationGuildCommands(process.env.CLIENT_ID, process.env.GUILD_ID),
            { body: commands },
        );

        console.log(`Successfully reloaded ${data.length} application (/) commands.`);
    } catch (error) {
        console.error(error);
    }
})();
</code></pre>
<p>The last thing we are going to do before we run our commands is create a deploy command in <code>package.json</code>. </p>
<pre><code class="language-json">&quot;deploy&quot;: &quot;node deploy-commands.js&quot;
</code></pre>
<p>We are going to run that command <code>yarn deploy</code> and if everything was done correctly, you should see <code>Successfully reloaded 2 application (/) commands.</code> logged out in your terminal.
Now we can run our bot with <code>yarn dev</code> and try out our first slash command!</p>
<h2 id="refactoring">Refactoring</h2>
<p>We would like to have all of our interactions out of our <code>main.js</code> file. The last thing we have in there is: </p>
<pre><code class="language-js">client.once(Events.ClientReady, c =&gt; {
    console.log(`Ready! Logged in as ${c.user.tag}`);
});
</code></pre>
<p>We would like to do the same treatment to our <code>Events</code> as we did for our <code>Commands</code>. Events can clutter up our main file and make it hard to read. 
We will create a new directory called <code>Event</code> and add two files, <code>ready.js</code> and <code>interactionCreate.js</code>. 
Similar to our first slash command, we will create our login event in <code>ready.js</code>:</p>
<pre><code class="language-js">const { Events } = require(&#39;discord.js&#39;);

module.exports = {
    name: Events.ClientReady,
    once: true,
    execute(client) {
        console.log(`Ready! Logged in as ${client.user.tag}`);
    },
};
</code></pre>
<p>We will also move over <code>Events.InteractionCreate</code> from our main file to <code>interactionCreate.js</code>:</p>
<pre><code class="language-js">const { Events } = require(&#39;discord.js&#39;);

module.exports = {
    name: Events.InteractionCreate,
    async execute(interaction) {
        if (!interaction.isChatInputCommand()) return;

        const command = interaction.client.commands.get(interaction.commandName);

        if (!command) {
            console.error(`No command matching ${interaction.commandName} was found.`);
            return;
        }

        try {
            await command.execute(interaction);
        } catch (error) {
            console.error(`Error executing ${interaction.commandName}`);
            console.error(error);
        }
    },
};
</code></pre>
<p>Now in our main file, to be able to read those event files, we will do almost exactly what we did to be able to read the command files: </p>
<pre><code class="language-js">const eventsPath = path.join(__dirname, &#39;events&#39;);
const eventFiles = fs.readdirSync(eventsPath).filter(file =&gt; file.endsWith(&#39;.js&#39;));

for (const file of eventFiles) {
    const filePath = path.join(eventsPath, file);
    const event = require(filePath);
    if (event.once) {
        client.once(event.name, (...args) =&gt; event.execute(...args));
    } else {
        client.on(event.name, (...args) =&gt; event.execute(...args));
    }
}
</code></pre>
<p>Run the bot to double check that it&#39;s working and you should see <code>Ready! Logged in as Book Club Bot 2.0#5180</code> printed out in your console. </p>
<p>Now we are done with the setup and can start creating our Book Club Bot!</p>
<h2 id="data-setup-for-book-club-bot">Data Setup for book club bot</h2>
<p>Create a new file for our book club bot in our commands directory named <code>bookClub.js</code>. We&#39;ll start off by importing the <code>SlashCommandBuilder</code> and adding the base code for our <code>data</code> property:</p>
<pre><code class="language-js">const { SlashCommandBuilder } = require(&#39;discord.js&#39;);

module.exports = {
  data: new SlashCommandBuilder()
    .setName(&#39;book-club&#39;)
    .setDescription(&#39;Creates a new book club!&#39;)
}
</code></pre>
<p>Now we get to implement one of the really cool features of discord.js which is <code>options</code>.  If we specify the type of option to be string, <code>addStringOption</code>, when the user uses the command, it will prompt them for an input of type <code>any</code> and it will convert it to a string. We are going to be using <code>addStringOption</code> and <code>addIntegerOption</code> to get the name of the book, number of people wanted, and when the submissions are closed. </p>
<pre><code class="language-js">const { SlashCommandBuilder } = require(&#39;discord.js&#39;);

module.exports = {
    data: new SlashCommandBuilder()
  .setName(&#39;book-club&#39;)
    .setDescription(&#39;Creates a new book club!&#39;)
    .addStringOption(op =&gt;
        op.setName(&#39;book&#39;)
            .setDescription(&#39;The book the book club is on&#39;)
            .setRequired(true))
    .addIntegerOption(option =&gt;
        option.setName(&#39;people&#39;)
            .setDescription(&#39;How many people you want for the club&#39;)
            .setRequired(true))
    .addIntegerOption(option =&gt; 
        option.setName(&#39;hours&#39;)
            .setDescription(&#39;When, in hours, you want enrolment closed&#39;)
            .setRequired(true)),
}
</code></pre>
<p>Now we can get to work on writing what is going to happen with those inputs in our <code>execute</code>. Discord.js is promise based so whenever you are fetching/sending with discord, you&#39;re going to almost always need <code>await</code>. </p>
<pre><code class="language-js">const book = interaction.options.getString(&#39;book&#39;);
        const bookClub = book + &#39; Book Club &#39; + moment().format(&#39;MMMM Do YYYY&#39;)

        const numOfPeople = interaction.options.getInteger(&#39;people&#39;)

        const hours = interaction.options.getInteger(&#39;hours&#39;)
        const waitTimeInSeconds = (hours * 60) * 60 
        const today = new Date()
        const todayUNIX = Math.floor(today.getTime() / 1000)
        const timeExpiresAt = todayUNIX + waitTimeInSeconds
</code></pre>
</article></div><footer class="flex justify-between mt-4"><div class="text-sm items-center">Lucas Minter ©<!-- -->2023</div><div class="flex"><div><a class="hover:text-gray-600" href="https://twitter.com/LucasMinter2"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAiIGhlaWdodD0iMzAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmVyc2lvbj0iMS4xIi8+"/></span><img alt="Twitter Logo" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%"/><noscript><img alt="Twitter Logo" srcSet="_next/static/media/twitterLogo.01f5f683.png?imwidth=32 1x, _next/static/media/twitterLogo.01f5f683.png?imwidth=64 2x" src="_next/static/media/twitterLogo.01f5f683.png?imwidth=64" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%" loading="lazy"/></noscript></span></a></div><div><a class="hover:text-gray-600" href="https://github.com/lsminter"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjUiIGhlaWdodD0iMjUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmVyc2lvbj0iMS4xIi8+"/></span><img alt="Github Logo" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%"/><noscript><img alt="Github Logo" srcSet="_next/static/media/githubLogo.c07b0dc3.png?imwidth=32 1x, _next/static/media/githubLogo.c07b0dc3.png?imwidth=64 2x" src="_next/static/media/githubLogo.c07b0dc3.png?imwidth=64" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%" loading="lazy"/></noscript></span></a></div></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"author":{"_createdAt":"2023-01-20T23:21:59Z","_id":"c87c5c26-aeb7-4a10-812d-98cb53801f40","_rev":"Jbh3e9W2SIs3qJeiZBiBWQ","_type":"author","_updatedAt":"2023-01-20T23:21:59Z","bio":[{"_key":"db9c4c531c02","_type":"block","children":[{"_key":"f311882b8511","_type":"span","marks":[],"text":"Author and creator of this blog."}],"markDefs":[],"style":"normal"}],"image":{"_type":"image","asset":{"_ref":"image-4685b1085a6d182cb91a1d85fd6878a604694ee6-1355x1799-jpg","_type":"reference"}},"name":"Lucas Minter","slug":{"_type":"slug","current":"lucas-minter"}},"body":"## WIP\nMake sure to talk about the discord channel for discord.js and their great documentation. You're probably going to want to create a bot channel in your server to do all of your testing since you'll probably be spamming it a good bit while testing. \n\n## Initial Files Setup\ndiscord.js v14 requires Node v16.9.0 or higher.\nCreate a project folder - `yarn init`\ninstall `discord.js` (I'm using v14.7.1), `nodemon` for development, and `dotenv` for environment variables\ncreate a `.env` file, we are going to store some variables there in a sec\nCreate a `.gitignore` file with node_modules and `.env` to make sure those don't get uploaded\n\n## Setup application on discord.com\nNavigate to https://discord.com/developers/applications\nYou'll need to sign up with an account if you have one\nClick new application\nName your bot\n- Save `application id` as `CLIENT_ID` in your `.env` file\n\nClick on bot\nClick `Add Bot`\nClick `Reset Token` and save that in your `.env` file as `TOKEN`. \n- Make sure to never show your token. Anyone will be able to use that to completely destroy the servers your bot is in. \nClick on `OAuth2` then `URL Generator`\nSelect `bot` then the permissions you want. \n- This all depends on what you plan on having your bot do, since this is a book club event bot, we need it to manage roles, manage channels, read messages/view channels, moderate members, send messages, manage messages, add reactions, and use slash commands. \nCopy the generated url and add it to your discord channel. \n\n## Logging in as your bot\nCreate a `main.js` file\nAdd the necessary imports:\n```js\nconst { Client, Events, GatewayIntentBits } = require('discord.js');\nrequire('dotenv').config()\n```\nCreate a new client instance:\n```js\nconst client = new Client({ intents: [GatewayIntentBits.Guilds] });\n```\nWith our client created, it's common practice to have your bot log once to make sure that it is working as intended:\n```js\nclient.once(Events.ClientReady, c =\u003e {\n  console.log(`Ready! Logged in as ${c.user.tag}`);\n})\n```\nLog into discord with your client's token:\n```js\nclient.login(process.env.TOKEN)\n```\nIn `package.json`, create a dev script using nodemon:\n```json\n\"dev\": \"nodemon main.js\"\n```\nRun `yarn dev` to see your bot start!\n\n## First command\nA simple first command is just a bot that replies to a specific message. At the bottom of `main.js`, we create our message command:\n```js\nclient.on('messageCreate', (message) =\u003e {\n\n})\n```\n`messageCreate` tells the bot that it's going to be a simple message command. Inside of that, we create an `if` block to check if the content of a message is exactly what we are looking for and then reply to that message. \n```js\nclient.on('messageCreate', (message) =\u003e {\n  if(message.content === 'hello'){\n    message.reply('world')\n  }\n})\n```\n\n## What are Slash Commands\nThe above is a good way to make a bot if it's going to be small and simple. The more complex your bot is, the more if/else blocks there are going to be. Your `main.js` file will get cluttered and be hard to read.\n\nSlash Commands allow you to separate our your commands into individual files as well as add some nice configurations that make creating commands simpler. \n\n(Taken from the discord tutorial)\n- Integration with the Discord client interface.\n- Automatic command detection and parsing of the associated options/arguments.\n- Typed argument inputs for command options, e.g. \"String\", \"User\", or \"Role\".\n- Validated or dynamic choices for command options.\n- In-channel private responses (ephemeral messages).\n- Pop-up form-style inputs for capturing additional information.\n\n## Slash Command File\nMake a new file called `commands/hello.js`.\nAdd the required imports for simple `hello world` command\n```js\nconst {SlashCommandBuilder} = require('discord.js');\n```\nExport the command:\n```js\nmodule.exports = {\n}\n```\nCreate the slash command. The `data` property will tell discord what the definition of our command is:\n```js\nmodule.exports = {\n  data: new SlashCommandBuilder()\n}\n```\nThe SlashCommandBuilder requires at least two things, the name of the command and a description.\n```js\nmodule.exports = {\n  data: new SlashCommandBuilder()\n    .setName('Hello')\n    .setDescription('Replies with World')\n}\n```\nNow we want to add code to our command. The `execute` method contains the code that the command is going to run:\n```js\nmodule.exports = {\n  data: new SlashCommandBuilder()\n    .setName('Hello')\n    .setDescription('Replies with World')\n  async execute(interaction) {\n    await interaction.reply('World!');\n  }\n}\n```\n\n## Load commands on startup\nIn `main.js`, we are going to use [`path`](https://nodejs.org/api/path.html) and [`fs`](https://nodejs.org/api/fs.html) from node to access the command files. We are also going to import `Collection` from discord.js\n```js\nconst fs = require('node:fs');\nconst path = require('node:path');\nconst { Client, Events, GatewayIntentBits, Collection } = require('discord.js');\n```\nNow we will want to attach `commands` to our client so that we can access those commands in other files:\n```js\nclient.commands = new Collection();\n```\n`new Collection()` here is mapping over our command files and giving our client access to those commands. \nI'm going to paste in some code from the discord.js guide to dynamically retrieve those command files with a little error handling:\n```js\nconst commandsPath = path.join(__dirname, 'commands');\nconst commandFiles = fs.readdirSync(commandsPath).filter(file =\u003e file.endsWith('.js'));\n\nfor (const file of commandFiles) {\n\tconst filePath = path.join(commandsPath, file);\n\tconst command = require(filePath);\n\tif ('data' in command \u0026\u0026 'execute' in command) {\n\t\tclient.commands.set(command.data.name, command);\n\t} else {\n\t\tconsole.log(`[WARNING] The command at ${filePath} is missing a required \"data\" or \"execute\" property.`);\n\t}\n}\n```\nNow that we have those command files, we are going to call the command's `.execute()` method and pass in the `interaction` variable as its argument. Going to paste in a little more code for that as well:\n```js\nclient.on(Events.InteractionCreate, async interaction =\u003e {\n\tif (!interaction.isChatInputCommand()) return;\n\n\tconst command = interaction.client.commands.get(interaction.commandName);\n\n\tif (!command) {\n\t\tconsole.error(`No command matching ${interaction.commandName} was found.`);\n\t\treturn;\n\t}\n\n\ttry {\n\t\tawait command.execute(interaction);\n\t} catch (error) {\n\t\tconsole.error(error);\n\t\tawait interaction.reply({ content: 'There was an error while executing this command!', ephemeral: true });\n\t}\n});\n```\n\n## Register Commands to Discord\nThis is where we need all three of our environment variables, `TOKEN`, `CLIENT_ID`, and now we need our server's id and save that in our `.env` file as `GUILD_ID`. \nTo get our server's id, in your Discord application, go to settings then Advanced and turn on `Developer Mode`. This will give you access to a lot of nice tools to make creating your bot easier. \nOne that we are going to use right now is right click on your server and `Copy ID`. \n\nNow we are going to create a file called `deploy-commands.js`. Here we are going to paste in the last bit of code that discord.js gives us on their guide. \n```js\nconst { REST, Routes } = require('discord.js');\nrequire('dotenv').config()\nconst fs = require('node:fs');\n\nconst commands = [];\nconst commandFiles = fs.readdirSync('./commands').filter(file =\u003e file.endsWith('.js'));\n\nfor (const file of commandFiles) {\n\tconst command = require(`./commands/${file}`);\n\tcommands.push(command.data.toJSON());\n}\n\nconst rest = new REST({ version: '10' }).setToken(process.env.TOKEN);\n\n(async () =\u003e {\n\ttry {\n\t\tconsole.log(`Started refreshing ${commands.length} application (/) commands.`);\n\n\t\tconst data = await rest.put(\n\t\t\tRoutes.applicationGuildCommands(process.env.CLIENT_ID, process.env.GUILD_ID),\n\t\t\t{ body: commands },\n\t\t);\n\n\t\tconsole.log(`Successfully reloaded ${data.length} application (/) commands.`);\n\t} catch (error) {\n\t\tconsole.error(error);\n\t}\n})();\n```\nThe last thing we are going to do before we run our commands is create a deploy command in `package.json`. \n```json\n\"deploy\": \"node deploy-commands.js\"\n```\nWe are going to run that command `yarn deploy` and if everything was done correctly, you should see `Successfully reloaded 2 application (/) commands.` logged out in your terminal.\nNow we can run our bot with `yarn dev` and try out our first slash command!\n\n## Refactoring\nWe would like to have all of our interactions out of our `main.js` file. The last thing we have in there is: \n```js\nclient.once(Events.ClientReady, c =\u003e {\n\tconsole.log(`Ready! Logged in as ${c.user.tag}`);\n});\n```\nWe would like to do the same treatment to our `Events` as we did for our `Commands`. Events can clutter up our main file and make it hard to read. \nWe will create a new directory called `Event` and add two files, `ready.js` and `interactionCreate.js`. \nSimilar to our first slash command, we will create our login event in `ready.js`:\n```js\nconst { Events } = require('discord.js');\n\nmodule.exports = {\n\tname: Events.ClientReady,\n\tonce: true,\n\texecute(client) {\n\t\tconsole.log(`Ready! Logged in as ${client.user.tag}`);\n\t},\n};\n```\nWe will also move over `Events.InteractionCreate` from our main file to `interactionCreate.js`:\n```js\nconst { Events } = require('discord.js');\n\nmodule.exports = {\n\tname: Events.InteractionCreate,\n\tasync execute(interaction) {\n\t\tif (!interaction.isChatInputCommand()) return;\n\n\t\tconst command = interaction.client.commands.get(interaction.commandName);\n\n\t\tif (!command) {\n\t\t\tconsole.error(`No command matching ${interaction.commandName} was found.`);\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tawait command.execute(interaction);\n\t\t} catch (error) {\n\t\t\tconsole.error(`Error executing ${interaction.commandName}`);\n\t\t\tconsole.error(error);\n\t\t}\n\t},\n};\n```\nNow in our main file, to be able to read those event files, we will do almost exactly what we did to be able to read the command files: \n```js\nconst eventsPath = path.join(__dirname, 'events');\nconst eventFiles = fs.readdirSync(eventsPath).filter(file =\u003e file.endsWith('.js'));\n\nfor (const file of eventFiles) {\n\tconst filePath = path.join(eventsPath, file);\n\tconst event = require(filePath);\n\tif (event.once) {\n\t\tclient.once(event.name, (...args) =\u003e event.execute(...args));\n\t} else {\n\t\tclient.on(event.name, (...args) =\u003e event.execute(...args));\n\t}\n}\n```\nRun the bot to double check that it's working and you should see `Ready! Logged in as Book Club Bot 2.0#5180` printed out in your console. \n\nNow we are done with the setup and can start creating our Book Club Bot!\n\n## Data Setup for book club bot\nCreate a new file for our book club bot in our commands directory named `bookClub.js`. We'll start off by importing the `SlashCommandBuilder` and adding the base code for our `data` property:\n```js\nconst { SlashCommandBuilder } = require('discord.js');\n\nmodule.exports = {\n  data: new SlashCommandBuilder()\n    .setName('book-club')\n    .setDescription('Creates a new book club!')\n}\n```\nNow we get to implement one of the really cool features of discord.js which is `options`.  If we specify the type of option to be string, `addStringOption`, when the user uses the command, it will prompt them for an input of type `any` and it will convert it to a string. We are going to be using `addStringOption` and `addIntegerOption` to get the name of the book, number of people wanted, and when the submissions are closed. \n```js\nconst { SlashCommandBuilder } = require('discord.js');\n\nmodule.exports = {\n\tdata: new SlashCommandBuilder()\n  .setName('book-club')\n\t.setDescription('Creates a new book club!')\n\t.addStringOption(op =\u003e\n\t\top.setName('book')\n\t\t\t.setDescription('The book the book club is on')\n\t\t\t.setRequired(true))\n\t.addIntegerOption(option =\u003e\n\t\toption.setName('people')\n\t\t\t.setDescription('How many people you want for the club')\n\t\t\t.setRequired(true))\n\t.addIntegerOption(option =\u003e \n\t\toption.setName('hours')\n\t\t\t.setDescription('When, in hours, you want enrolment closed')\n\t\t\t.setRequired(true)),\n}\n```\n\nNow we can get to work on writing what is going to happen with those inputs in our `execute`. Discord.js is promise based so whenever you are fetching/sending with discord, you're going to almost always need `await`. \n\n```js\nconst book = interaction.options.getString('book');\n\t\tconst bookClub = book + ' Book Club ' + moment().format('MMMM Do YYYY')\n\n\t\tconst numOfPeople = interaction.options.getInteger('people')\n\n\t\tconst hours = interaction.options.getInteger('hours')\n\t\tconst waitTimeInSeconds = (hours * 60) * 60 \n\t\tconst today = new Date()\n\t\tconst todayUNIX = Math.floor(today.getTime() / 1000)\n\t\tconst timeExpiresAt = todayUNIX + waitTimeInSeconds\n```","publishedAt":"2023-01-21T03:30:00.000Z","slug":{"_type":"slug","current":"how-to-make-a-discord-bot"},"title":"How to make a discord bot"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"how-to-make-a-discord-bot"},"buildId":"EnhcvAUsi813Z5H5Qa9-b","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>